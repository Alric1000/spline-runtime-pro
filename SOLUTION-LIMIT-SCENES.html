<!-- SOLUTION: Limit concurrent scenes to maintain quality -->
<!-- Replace your GLOBAL FOOTER code with this -->

<script async src="https://cdn.jsdelivr.net/npm/@finsweet/cookie-consent@1/fs-cc.js" fs-cc-mode="opt-in"></script>

<script>
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const dpr = window.devicePixelRatio || 1;

    // CRITICAL: Limit to 3 concurrent scenes to maintain quality!
    const MAX_CONCURRENT_SCENES = 3;

    console.log(`[SPLINE] Device pixel ratio: ${dpr}`);
    console.log(`[SPLINE] Max concurrent scenes: ${MAX_CONCURRENT_SCENES}`);

    let activeViewers = new Set();
    let viewerQueue = [];

    // Wait for spline-viewer to be defined
    function waitForSplineViewer() {
        return new Promise((resolve) => {
            const check = setInterval(() => {
                if (customElements.get('spline-viewer')) {
                    clearInterval(check);
                    resolve();
                }
            }, 50);
        });
    }

    // Create viewer in container
    function createViewer(container) {
        const sceneName = container.dataset.scene;
        if (!sceneName) return null;

        // Check if viewer already exists
        if (container.querySelector('spline-viewer')) {
            return container.querySelector('spline-viewer');
        }

        // Create spline-viewer element
        const viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${sceneName}/scene.splinecode`);
        viewer.setAttribute('id', container.id + '-viewer');

        // Start hidden
        viewer.style.visibility = 'hidden';

        container.appendChild(viewer);
        console.log(`[SPLINE] Created viewer for ${sceneName}`);

        return viewer;
    }

    // Activate a viewer (make visible and fix pixel ratio)
    function activateViewer(viewer) {
        if (activeViewers.has(viewer)) return;

        // Check if we're at max capacity
        if (activeViewers.size >= MAX_CONCURRENT_SCENES) {
            // Add to queue instead
            if (!viewerQueue.includes(viewer)) {
                viewerQueue.push(viewer);
                console.log(`[SPLINE] Queued viewer (${viewerQueue.length} in queue)`);
            }
            return false;
        }

        // Activate the viewer
        viewer.style.visibility = 'visible';
        activeViewers.add(viewer);

        console.log(`[SPLINE] Activated viewer (${activeViewers.size}/${MAX_CONCURRENT_SCENES} active)`);

        // Fix pixel ratio multiple times
        fixViewerPixelRatio(viewer);
        setTimeout(() => fixViewerPixelRatio(viewer), 500);
        setTimeout(() => fixViewerPixelRatio(viewer), 1000);

        return true;
    }

    // Deactivate a viewer
    function deactivateViewer(viewer) {
        if (!activeViewers.has(viewer)) return;

        viewer.style.visibility = 'hidden';
        activeViewers.delete(viewer);

        console.log(`[SPLINE] Deactivated viewer (${activeViewers.size}/${MAX_CONCURRENT_SCENES} active)`);

        // Check if we can activate something from the queue
        if (viewerQueue.length > 0 && activeViewers.size < MAX_CONCURRENT_SCENES) {
            const nextViewer = viewerQueue.shift();
            activateViewer(nextViewer);
        }
    }

    // Fix pixel ratio for a specific viewer
    function fixViewerPixelRatio(viewer) {
        const canvas = viewer.shadowRoot?.querySelector('canvas') || viewer.querySelector('canvas');

        if (canvas) {
            const rect = canvas.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);

            // Set correct dimensions
            if (canvas.width !== width * dpr) {
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                console.log(`[SPLINE] Fixed canvas to ${width * dpr}x${height * dpr}`);
            }

            // Try to fix renderer
            const paths = [
                viewer._scene?._renderer,
                viewer._application?._renderer,
                viewer.application?._renderer,
                viewer.renderer
            ];

            for (const renderer of paths) {
                if (renderer?.setPixelRatio) {
                    renderer.setPixelRatio(dpr);

                    // IMPORTANT: Ensure high quality rendering
                    if (renderer.setSize) {
                        renderer.setSize(width, height, false);
                    }

                    // Force high quality settings if available
                    if (renderer.shadowMap) {
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = 2; // PCFSoftShadowMap
                    }

                    console.log('[SPLINE] Renderer pixel ratio set and quality ensured');
                    break;
                }
            }
        }
    }

    // Setup intersection observer for smart loading
    function setupSmartLoading(viewer, container) {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                activateViewer(viewer);
            } else {
                deactivateViewer(viewer);
            }
        }, {
            rootMargin: '50px', // Reduced margin for tighter control
            threshold: 0.1
        });

        observer.observe(container);
    }

    // Main initialization
    async function initialize() {
        await waitForSplineViewer();

        // Find all spline containers
        const containers = document.querySelectorAll('.spline-container');
        console.log(`[SPLINE] Found ${containers.length} containers`);

        // Create viewers and setup smart loading
        containers.forEach(container => {
            const viewer = createViewer(container);
            if (viewer) {
                setupSmartLoading(viewer, container);
            }
        });

        // Also activate first N viewers immediately if visible
        const visibleContainers = Array.from(containers).filter(container => {
            const rect = container.getBoundingClientRect();
            return rect.top < window.innerHeight && rect.bottom > 0;
        });

        visibleContainers.slice(0, MAX_CONCURRENT_SCENES).forEach(container => {
            const viewer = container.querySelector('spline-viewer');
            if (viewer) activateViewer(viewer);
        });
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }

    // Manual commands
    window.splineControl = {
        status: () => {
            console.log(`Active: ${activeViewers.size}/${MAX_CONCURRENT_SCENES}`);
            console.log(`Queued: ${viewerQueue.length}`);
            console.log('Active viewers:', Array.from(activeViewers).map(v => v.id));
        },

        setMaxScenes: (max) => {
            console.log(`[SPLINE] Changing max scenes from ${MAX_CONCURRENT_SCENES} to ${max}`);
            // This would need to be restructured to make MAX_CONCURRENT_SCENES mutable
        },

        forceQuality: () => {
            activeViewers.forEach(viewer => {
                fixViewerPixelRatio(viewer);
            });
            console.log('[SPLINE] Forced quality fix on all active viewers');
        },

        checkPixelRatios: () => {
            document.querySelectorAll('spline-viewer').forEach(viewer => {
                const canvas = viewer.shadowRoot?.querySelector('canvas') || viewer.querySelector('canvas');
                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const correct = canvas.width === rect.width * dpr;
                    const visibility = viewer.style.visibility;
                    console.log(`${viewer.id}: ${correct ? '✅' : '❌'} ${canvas.width}x${canvas.height} (${visibility})`);
                }
            });
        }
    };

    console.log('[SPLINE] Initialized with quality-preserving limits');
    console.log('[SPLINE] Commands: splineControl.status(), splineControl.forceQuality(), splineControl.checkPixelRatios()');
})();
</script>