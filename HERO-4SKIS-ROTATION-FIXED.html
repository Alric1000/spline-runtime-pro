<!-- HERO 4-SKIS COMBINED SCENE WITH FIXED ROTATION -->
<!-- Enhanced Spline API access for rotation control -->

<script async src="https://cdn.jsdelivr.net/npm/@finsweet/cookie-consent@1/fs-cc.js" fs-cc-mode="opt-in"></script>

<script>
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const HERO_SCENE = 'hero-animation';
    const dpr = window.devicePixelRatio || 1;

    console.log('[HERO-4SKIS] Initializing with enhanced rotation support');

    let viewer = null;
    let splineApp = null;
    let sceneObjects = {};
    let isInteracting = false;
    let currentSki = null;
    let startX = 0;
    let currentRotations = {
        ALLMOUNTAIN: 0,
        PARK: 0,
        CARVE: 0,
        POWDER: 0
    };

    // Wait for spline-viewer to be defined
    function waitForSplineViewer() {
        return new Promise((resolve) => {
            const check = setInterval(() => {
                if (customElements.get('spline-viewer')) {
                    clearInterval(check);
                    resolve();
                }
            }, 50);
        });
    }

    // Create the hero viewer
    function createHeroViewer(container) {
        viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${HERO_SCENE}/scene.splinecode`);
        viewer.setAttribute('id', 'hero-viewer');
        viewer.style.width = '100%';
        viewer.style.height = '100%';
        viewer.style.display = 'block';

        container.appendChild(viewer);

        // Setup multiple event listeners for Spline load
        viewer.addEventListener('load', onSplineLoad);
        viewer.addEventListener('ready', onSplineLoad);
        viewer.addEventListener('loaded', onSplineLoad);

        // Also check periodically for Spline app
        const checkInterval = setInterval(() => {
            if (tryAccessSplineApp()) {
                clearInterval(checkInterval);
                setupInteraction();
            }
        }, 500);

        // Timeout after 10 seconds
        setTimeout(() => clearInterval(checkInterval), 10000);

        return viewer;
    }

    // Handle Spline load event
    function onSplineLoad() {
        console.log('[HERO-4SKIS] Spline loaded event fired');

        // Try multiple times with delays
        setTimeout(() => {
            tryAccessSplineApp();
            fixQuality(viewer);
            setupInteraction();
        }, 100);

        setTimeout(() => {
            tryAccessSplineApp();
            findSceneObjects();
        }, 500);

        setTimeout(() => {
            tryAccessSplineApp();
            findSceneObjects();
        }, 1000);
    }

    // Try to access Spline application through various methods
    function tryAccessSplineApp() {
        if (splineApp) return true;

        // Method 1: Direct properties
        const attempts = [
            () => viewer._application,
            () => viewer.application,
            () => viewer._app,
            () => viewer.spline,
            () => viewer._spline,
            () => viewer.shadowRoot?.querySelector('canvas')?._splineApp,
            () => viewer.querySelector('canvas')?._splineApp,
            () => window.SPLINE?.apps?.[0],
            () => window.splineApp
        ];

        for (const attempt of attempts) {
            try {
                const app = attempt();
                if (app) {
                    splineApp = app;
                    console.log('[HERO-4SKIS] Spline app accessed successfully');

                    // Store globally for debugging
                    window.splineApp = app;

                    findSceneObjects();
                    return true;
                }
            } catch (e) {}
        }

        // Method 2: Check iframe content
        try {
            const iframe = viewer.querySelector('iframe');
            if (iframe?.contentWindow?.SPLINE) {
                splineApp = iframe.contentWindow.SPLINE.apps?.[0];
                if (splineApp) {
                    console.log('[HERO-4SKIS] Spline app accessed through iframe');
                    window.splineApp = splineApp;
                    findSceneObjects();
                    return true;
                }
            }
        } catch (e) {}

        return false;
    }

    // Find all scene objects
    function findSceneObjects() {
        if (!splineApp) return;

        const skiNames = ['ALLMOUNTAIN', 'PARK', 'CARVE', 'POWDER'];

        console.log('[HERO-4SKIS] Searching for scene objects...');

        // Method 1: Direct scene traversal
        if (splineApp.scene) {
            traverseScene(splineApp.scene);
        }

        // Method 2: getAllObjects
        if (splineApp.getAllObjects) {
            const objects = splineApp.getAllObjects();
            console.log('[HERO-4SKIS] Found objects:', objects.map(o => o.name));

            for (const name of skiNames) {
                const obj = objects.find(o => o.name === name || o.name.includes(name));
                if (obj) {
                    sceneObjects[name] = obj;
                    console.log(`[HERO-4SKIS] Found ${name} object`);
                }
            }
        }

        // Method 3: findObjectByName
        if (splineApp.findObjectByName) {
            for (const name of skiNames) {
                const obj = splineApp.findObjectByName(name);
                if (obj) {
                    sceneObjects[name] = obj;
                    console.log(`[HERO-4SKIS] Found ${name} via findObjectByName`);
                }
            }
        }

        // Log what we found
        console.log('[HERO-4SKIS] Scene objects found:', Object.keys(sceneObjects));
    }

    // Traverse scene hierarchy
    function traverseScene(obj, depth = 0) {
        if (!obj) return;

        const skiNames = ['ALLMOUNTAIN', 'PARK', 'CARVE', 'POWDER'];

        // Check current object
        if (obj.name) {
            console.log(`${'  '.repeat(depth)}Object: ${obj.name}`);

            for (const skiName of skiNames) {
                if (obj.name === skiName || obj.name.includes(skiName)) {
                    sceneObjects[skiName] = obj;
                    console.log(`[HERO-4SKIS] Found ${skiName} in scene traverse`);
                }
            }
        }

        // Check children
        if (obj.children) {
            for (const child of obj.children) {
                traverseScene(child, depth + 1);
            }
        }
    }

    // Fix quality for high DPI
    function fixQuality(viewer) {
        setTimeout(() => {
            const canvas = viewer.shadowRoot?.querySelector('canvas') ||
                          viewer.querySelector('canvas');

            if (canvas) {
                const rect = canvas.getBoundingClientRect();
                const width = Math.floor(rect.width);
                const height = Math.floor(rect.height);

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                console.log('[HERO-4SKIS] Canvas quality fixed');
            }
        }, 500);
    }

    // Determine which ski based on X position
    function getSkiFromPosition(x, canvasWidth) {
        const zone = Math.floor((x / canvasWidth) * 4);
        return Math.min(Math.max(zone, 0), 3);
    }

    // Get ski name by index
    function getSkiName(index) {
        const names = ['ALLMOUNTAIN', 'PARK', 'CARVE', 'POWDER'];
        return names[index];
    }

    // Setup interaction handlers
    function setupInteraction() {
        const canvas = viewer.shadowRoot?.querySelector('canvas') ||
                      viewer.querySelector('canvas');

        if (!canvas) {
            console.warn('[HERO-4SKIS] Canvas not found, retrying...');
            setTimeout(setupInteraction, 500);
            return;
        }

        // Prevent default behaviors
        canvas.style.touchAction = 'none';
        canvas.style.userSelect = 'none';
        canvas.style.webkitUserSelect = 'none';
        canvas.style.cursor = 'grab';

        // Remove existing listeners
        canvas.removeEventListener('mousedown', handleStart);
        canvas.removeEventListener('touchstart', handleStart);

        // Add interaction handlers
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false });

        console.log('[HERO-4SKIS] Interaction handlers attached');
    }

    // Handle interaction start
    function handleStart(e) {
        e.preventDefault();

        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const x = clientX - rect.left;

        currentSki = getSkiFromPosition(x, rect.width);
        const skiName = getSkiName(currentSki);

        isInteracting = true;
        startX = clientX;

        canvas.style.cursor = 'grabbing';

        console.log(`[HERO-4SKIS] Started interacting with ${skiName}`);

        // Try to access Spline app again if needed
        if (!splineApp) {
            tryAccessSplineApp();
        }
    }

    // Handle interaction move
    function handleMove(e) {
        if (!isInteracting || currentSki === null) return;

        e.preventDefault();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const deltaX = clientX - startX;
        const skiName = getSkiName(currentSki);

        // Calculate rotation (adjust sensitivity as needed)
        const rotation = (deltaX * 0.5);

        // Apply rotation
        applyRotation(skiName, rotation);
    }

    // Handle interaction end
    function handleEnd(e) {
        if (!isInteracting) return;

        e.preventDefault();

        isInteracting = false;

        if (currentSki !== null) {
            const skiName = getSkiName(currentSki);
            animateBackToOriginal(skiName);
        }

        const canvas = e.target;
        if (canvas) {
            canvas.style.cursor = 'grab';
        }

        currentSki = null;
    }

    // Apply rotation to specific ski
    function applyRotation(skiName, rotation) {
        const rotationRad = rotation * (Math.PI / 180);

        // Method 1: Use cached object
        if (sceneObjects[skiName]) {
            sceneObjects[skiName].rotation.y = rotationRad;
            currentRotations[skiName] = rotation;
            console.log(`[HERO-4SKIS] Rotating ${skiName} to ${rotation}°`);
            return;
        }

        // Method 2: Try to find object again
        if (splineApp) {
            let obj = null;

            // Try different access methods
            if (splineApp.findObjectByName) {
                obj = splineApp.findObjectByName(skiName);
            } else if (splineApp.scene?.getObjectByName) {
                obj = splineApp.scene.getObjectByName(skiName);
            }

            if (obj) {
                obj.rotation.y = rotationRad;
                sceneObjects[skiName] = obj; // Cache it
                currentRotations[skiName] = rotation;
                console.log(`[HERO-4SKIS] Rotating ${skiName} to ${rotation}° (found dynamically)`);
                return;
            }
        }

        // Method 3: Use Spline Events API
        if (viewer.emitEvent || viewer.emit) {
            const emitFunc = viewer.emitEvent || viewer.emit;
            emitFunc.call(viewer, 'rotate', {
                target: skiName,
                rotation: rotation
            });
            currentRotations[skiName] = rotation;
            console.log(`[HERO-4SKIS] Sent rotate event for ${skiName}`);
        }

        // Method 4: PostMessage fallback
        sendSplineMessage(skiName, rotation);
    }

    // Animate back to original position
    function animateBackToOriginal(skiName) {
        const startRot = currentRotations[skiName];
        const endRot = 0;
        const duration = 500;
        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Easing
            const eased = 1 - Math.pow(1 - progress, 3);

            const rotation = startRot + (endRot - startRot) * eased;
            applyRotation(skiName, rotation);

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }

        animate();
    }

    // PostMessage fallback
    function sendSplineMessage(skiName, rotation) {
        try {
            // Try viewer's contentWindow
            if (viewer.contentWindow) {
                viewer.contentWindow.postMessage({
                    type: 'rotate',
                    target: skiName,
                    rotation: rotation
                }, '*');
            }

            // Try iframe
            const iframe = viewer.querySelector('iframe');
            if (iframe?.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'rotate',
                    target: skiName,
                    rotation: rotation
                }, '*');
            }
        } catch (e) {}
    }

    // Initialize
    async function initialize() {
        await waitForSplineViewer();

        const container = document.querySelector('.spline-container, .hero-container, #hero-container');

        if (!container) {
            console.error('[HERO-4SKIS] No container found');
            return;
        }

        createHeroViewer(container);

        console.log('[HERO-4SKIS] Initialized with enhanced rotation support');
    }

    // Start
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        setTimeout(initialize, 100);
    }

    // Debug utilities
    window.hero4Skis = {
        status: () => {
            console.log('[HERO-4SKIS] Status:');
            console.log('- Viewer:', viewer ? 'loaded' : 'not loaded');
            console.log('- Spline App:', splineApp ? 'connected' : 'not connected');
            console.log('- Scene Objects:', Object.keys(sceneObjects));
            console.log('- Current Rotations:', currentRotations);
        },

        testRotation: (skiName, degrees) => {
            console.log(`[HERO-4SKIS] Testing ${skiName} rotation to ${degrees}°`);
            applyRotation(skiName, degrees);
            setTimeout(() => animateBackToOriginal(skiName), 1000);
        },

        findObjects: () => {
            tryAccessSplineApp();
            findSceneObjects();
        },

        debugSpline: () => {
            console.log('[HERO-4SKIS] Debug info:');
            console.log('- viewer:', viewer);
            console.log('- viewer._application:', viewer?._application);
            console.log('- viewer.application:', viewer?.application);
            console.log('- viewer.spline:', viewer?.spline);
            console.log('- window.SPLINE:', window.SPLINE);
            console.log('- splineApp:', splineApp);
            console.log('- sceneObjects:', sceneObjects);
        }
    };

    console.log('[HERO-4SKIS] Debug commands:');
    console.log('- hero4Skis.status()');
    console.log('- hero4Skis.testRotation("ALLMOUNTAIN", 45)');
    console.log('- hero4Skis.findObjects()');
    console.log('- hero4Skis.debugSpline()');
})();
</script>

<!-- WEBFLOW SETUP -->
<!--
In Webflow, create a single container:

<div class="hero-container" id="hero-container"></div>

Or use existing spline-container:

<div class="spline-container" id="hero-container"></div>
-->