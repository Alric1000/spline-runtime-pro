<!-- WORKAROUND SOLUTIONS FOR 4-SCENE QUALITY ISSUE -->

<!-- ============================================
     SOLUTION 1: SHOW 3, ROTATE THE 4TH
     ============================================ -->

<!-- This shows 3 scenes + rotates which one is hidden based on scroll -->

<script>
// SOLUTION 1: Dynamic 3-scene rotation
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const dpr = window.devicePixelRatio || 1;
    const MAX_QUALITY_SCENES = 3; // Browser limit for quality

    console.log('[ROTATE-3] Implementing 3-scene rotation for quality');

    let allViewers = [];
    let activeViewers = new Set();
    let viewportCenter = 0;

    async function initialize() {
        // Wait for custom element
        while (!customElements.get('spline-viewer')) {
            await new Promise(r => setTimeout(r, 50));
        }

        // Create all viewers
        const containers = document.querySelectorAll('.spline-container');
        containers.forEach(container => {
            const viewer = createViewer(container);
            if (viewer) {
                allViewers.push({ viewer, container });
            }
        });

        // Update on scroll
        window.addEventListener('scroll', updateVisibleScenes);
        window.addEventListener('resize', updateVisibleScenes);

        // Initial update
        updateVisibleScenes();
    }

    function updateVisibleScenes() {
        viewportCenter = window.scrollY + (window.innerHeight / 2);

        // Calculate distance from viewport center for each viewer
        const viewerDistances = allViewers.map(item => {
            const rect = item.container.getBoundingClientRect();
            const elementCenter = rect.top + (rect.height / 2) + window.scrollY;
            const distance = Math.abs(viewportCenter - elementCenter);
            return { ...item, distance };
        });

        // Sort by distance (closest first)
        viewerDistances.sort((a, b) => a.distance - b.distance);

        // Show closest 3, hide the rest
        viewerDistances.forEach((item, index) => {
            if (index < MAX_QUALITY_SCENES) {
                showViewer(item.viewer);
            } else {
                hideViewer(item.viewer);
            }
        });
    }

    function showViewer(viewer) {
        if (!activeViewers.has(viewer)) {
            viewer.style.visibility = 'visible';
            activeViewers.add(viewer);
            forceQuality(viewer);
            console.log(`[ROTATE-3] Showing viewer (${activeViewers.size}/3 active)`);
        }
    }

    function hideViewer(viewer) {
        if (activeViewers.has(viewer)) {
            viewer.style.visibility = 'hidden';
            activeViewers.delete(viewer);
            console.log(`[ROTATE-3] Hiding viewer (${activeViewers.size}/3 active)`);
        }
    }

    function createViewer(container) {
        // Implementation same as before
        const sceneName = container.dataset.scene;
        if (!sceneName) return null;

        const viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${sceneName}/scene.splinecode`);
        viewer.style.visibility = 'hidden'; // Start hidden
        container.appendChild(viewer);

        return viewer;
    }

    function forceQuality(viewer) {
        // Quality forcing code from before
        setTimeout(() => {
            const canvas = viewer.shadowRoot?.querySelector('canvas') || viewer.querySelector('canvas');
            if (canvas) {
                const rect = canvas.getBoundingClientRect();
                const width = Math.floor(rect.width);
                const height = Math.floor(rect.height);
                canvas.width = width * dpr;
                canvas.height = height * dpr;
            }
        }, 100);
    }

    // Initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }

    window.rotate3 = {
        status: () => {
            console.log(`Active: ${activeViewers.size}/3`);
            console.log('Visible viewers:', Array.from(activeViewers));
        }
    };
})();
</script>


<!-- ============================================
     SOLUTION 2: CLICK TO ACTIVATE 4TH SCENE
     ============================================ -->

<!-- Show 3 by default, click to swap in the 4th -->

<script>
// SOLUTION 2: Click to activate 4th scene
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const MAX_AUTO_SCENES = 3;

    let viewers = new Map();
    let activeViewers = new Set();

    function initialize() {
        const containers = document.querySelectorAll('.spline-container');

        containers.forEach((container, index) => {
            const viewer = createViewer(container);

            if (index < MAX_AUTO_SCENES) {
                // First 3 scenes - show automatically
                viewer.style.visibility = 'visible';
                activeViewers.add(viewer);
            } else {
                // 4th scene - requires click
                viewer.style.visibility = 'hidden';

                // Add click overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.7);
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    z-index: 10;
                `;
                overlay.innerHTML = '<div>Click to load 3D view</div>';

                overlay.onclick = () => {
                    // Hide one of the active viewers
                    const toHide = Array.from(activeViewers)[0];
                    if (toHide) {
                        toHide.style.visibility = 'hidden';
                        activeViewers.delete(toHide);
                    }

                    // Show this viewer
                    viewer.style.visibility = 'visible';
                    activeViewers.add(viewer);
                    overlay.remove();

                    console.log('[CLICK-4] Swapped viewers, maintaining 3 active');
                };

                container.style.position = 'relative';
                container.appendChild(overlay);
            }

            viewers.set(container, viewer);
        });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();
</script>


<!-- ============================================
     SOLUTION 3: PROGRESSIVE ENHANCEMENT
     ============================================ -->

<!-- Start with low quality for all 4, enhance on hover/focus -->

<script>
// SOLUTION 3: Progressive quality enhancement
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const dpr = window.devicePixelRatio || 1;

    let viewers = [];
    let enhancedViewers = new Set();
    const MAX_ENHANCED = 3;

    function initialize() {
        const containers = document.querySelectorAll('.spline-container');

        containers.forEach(container => {
            const viewer = createViewer(container);
            viewers.push(viewer);

            // Start all in low quality
            setLowQuality(viewer);

            // Enhance on hover
            container.addEventListener('mouseenter', () => {
                requestEnhancement(viewer);
            });

            // Optionally reduce on mouse leave
            container.addEventListener('mouseleave', () => {
                // Keep enhanced if under limit
                if (enhancedViewers.size > MAX_ENHANCED) {
                    setLowQuality(viewer);
                    enhancedViewers.delete(viewer);
                }
            });
        });

        // Enhance first 3 by default
        viewers.slice(0, MAX_ENHANCED).forEach(requestEnhancement);
    }

    function requestEnhancement(viewer) {
        if (enhancedViewers.has(viewer)) return;

        if (enhancedViewers.size >= MAX_ENHANCED) {
            // Downgrade the oldest enhanced viewer
            const oldest = Array.from(enhancedViewers)[0];
            setLowQuality(oldest);
            enhancedViewers.delete(oldest);
        }

        setHighQuality(viewer);
        enhancedViewers.add(viewer);
    }

    function setHighQuality(viewer) {
        const canvas = viewer.shadowRoot?.querySelector('canvas') || viewer.querySelector('canvas');
        if (canvas) {
            const rect = canvas.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            console.log('[PROGRESSIVE] Enhanced quality');
        }
    }

    function setLowQuality(viewer) {
        const canvas = viewer.shadowRoot?.querySelector('canvas') || viewer.querySelector('canvas');
        if (canvas) {
            const rect = canvas.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);
            // Use lower pixel ratio for non-enhanced
            canvas.width = width * 1;
            canvas.height = height * 1;
            console.log('[PROGRESSIVE] Reduced quality');
        }
    }

    function createViewer(container) {
        const sceneName = container.dataset.scene;
        if (!sceneName) return null;

        const viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${sceneName}/scene.splinecode`);
        container.appendChild(viewer);

        return viewer;
    }

    // Initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();
</script>