<!-- HERO 4-SKIS COMBINED SCENE WITH TOUCH ROTATION -->
<!-- Single scene with all 4 skis = Perfect quality! -->

<script async src="https://cdn.jsdelivr.net/npm/@finsweet/cookie-consent@1/fs-cc.js" fs-cc-mode="opt-in"></script>

<script>
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const HERO_SCENE = 'hero-animation'; // Your new combined scene
    const dpr = window.devicePixelRatio || 1;

    console.log('[HERO-4SKIS] Initializing combined scene with rotation');

    let viewer = null;
    let isInteracting = false;
    let currentSki = null;
    let startX = 0;
    let startRotation = 0;
    let targetRotation = 0;
    let currentRotation = 0;
    let animationFrame = null;

    // Original rotations for spring-back
    const originalRotations = {
        ski1: 0,
        ski2: 0,
        ski3: 0,
        ski4: 0
    };

    // Wait for spline-viewer
    function waitForSplineViewer() {
        return new Promise((resolve) => {
            const check = setInterval(() => {
                if (customElements.get('spline-viewer')) {
                    clearInterval(check);
                    resolve();
                }
            }, 50);
        });
    }

    // Create the single viewer for all 4 skis
    function createHeroViewer(container) {
        viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${HERO_SCENE}/scene.splinecode`);
        viewer.setAttribute('id', 'hero-viewer');
        viewer.style.width = '100%';
        viewer.style.height = '100%';
        viewer.style.display = 'block';

        // Disable default Spline interactions
        viewer.setAttribute('mouse-controls', 'false');

        container.appendChild(viewer);

        // Fix quality after load
        viewer.addEventListener('load', () => {
            fixQuality(viewer);
            setupInteraction();
        });

        return viewer;
    }

    // Fix quality for high DPI
    function fixQuality(viewer) {
        setTimeout(() => {
            const canvas = viewer.shadowRoot?.querySelector('canvas') ||
                          viewer.querySelector('canvas');

            if (canvas) {
                const rect = canvas.getBoundingClientRect();
                const width = Math.floor(rect.width);
                const height = Math.floor(rect.height);

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                // Try to fix renderer
                const paths = [
                    () => viewer._scene?._renderer,
                    () => viewer._application?._renderer,
                    () => viewer.application?._renderer,
                    () => viewer.spline?._renderer
                ];

                for (const getPath of paths) {
                    try {
                        const renderer = getPath();
                        if (renderer?.setPixelRatio) {
                            renderer.setPixelRatio(dpr);
                            renderer.setSize(width, height, false);
                            console.log('[HERO-4SKIS] Quality fixed');
                            break;
                        }
                    } catch (e) {}
                }
            }
        }, 500);
    }

    // Determine which ski based on X position (divide canvas into 4 zones)
    function getSkiFromPosition(x, canvasWidth) {
        const zone = Math.floor((x / canvasWidth) * 4);
        return Math.min(Math.max(zone, 0), 3); // Clamp to 0-3
    }

    // Setup interaction handlers
    function setupInteraction() {
        const canvas = viewer.shadowRoot?.querySelector('canvas') ||
                      viewer.querySelector('canvas');

        if (!canvas) {
            console.warn('[HERO-4SKIS] Canvas not found for interaction');
            return;
        }

        // Prevent default touch behaviors
        canvas.style.touchAction = 'none';
        canvas.style.userSelect = 'none';
        canvas.style.webkitUserSelect = 'none';

        // MOUSE EVENTS
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        // TOUCH EVENTS (Mobile)
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false });

        console.log('[HERO-4SKIS] Interaction handlers attached');
    }

    // Handle interaction start (mouse/touch down)
    function handleStart(e) {
        e.preventDefault();

        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();

        // Get position from mouse or touch
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const x = clientX - rect.left;

        // Determine which ski
        currentSki = getSkiFromPosition(x, rect.width);

        isInteracting = true;
        startX = clientX;
        startRotation = currentRotation;

        // Visual feedback
        canvas.style.cursor = 'grabbing';

        console.log(`[HERO-4SKIS] Started interacting with ski ${currentSki + 1}`);
    }

    // Handle interaction move (mouse/touch move)
    function handleMove(e) {
        if (!isInteracting || currentSki === null) return;

        e.preventDefault();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const deltaX = clientX - startX;

        // Calculate rotation based on drag distance
        // Adjust sensitivity as needed (0.5 = rotation speed)
        targetRotation = startRotation + (deltaX * 0.5);

        // Apply rotation to the specific ski
        applyRotation(currentSki, targetRotation);
    }

    // Handle interaction end (mouse/touch up)
    function handleEnd(e) {
        if (!isInteracting) return;

        e.preventDefault();

        isInteracting = false;

        // Spring back to original rotation
        if (currentSki !== null) {
            animateBackToOriginal(currentSki);
        }

        // Reset cursor
        const canvas = e.target;
        if (canvas) {
            canvas.style.cursor = 'grab';
        }

        console.log(`[HERO-4SKIS] Ended interaction with ski ${currentSki + 1}`);
        currentSki = null;
    }

    // Apply rotation to specific ski (needs Spline API access)
    function applyRotation(skiIndex, rotation) {
        // This is where we need to access the Spline scene objects
        // For now, we'll try to access through the viewer API

        try {
            // Attempt to access the Spline application
            const app = viewer._application || viewer.application || viewer._app || viewer.spline;

            if (app) {
                // Updated group names to match your scene
                const skiNames = ['ALLMOUNTAIN', 'PARK', 'CARVE', 'POWDER'];

                // Try different methods to find the object
                let skiObject = null;

                // Method 1: Direct scene access
                if (app.scene && app.scene.getObjectByName) {
                    skiObject = app.scene.getObjectByName(skiNames[skiIndex]);
                }

                // Method 2: Through findObjectByName
                if (!skiObject && app.findObjectByName) {
                    skiObject = app.findObjectByName(skiNames[skiIndex]);
                }

                // Method 3: Through getAllObjects
                if (!skiObject && app.getAllObjects) {
                    const objects = app.getAllObjects();
                    skiObject = objects.find(obj => obj.name === skiNames[skiIndex]);
                }

                if (skiObject) {
                    // Apply Y-axis rotation
                    skiObject.rotation.y = rotation * (Math.PI / 180);
                    console.log(`[HERO-4SKIS] Rotating ${skiNames[skiIndex]} to ${rotation}°`);
                } else {
                    console.log(`[HERO-4SKIS] Could not find object: ${skiNames[skiIndex]}`);
                    // Fallback: Try to send message to Spline
                    sendSplineMessage(skiIndex, rotation);
                }
            } else {
                console.warn('[HERO-4SKIS] Spline app not accessible');
                // Fallback: Try to send message to Spline
                sendSplineMessage(skiIndex, rotation);
            }
        } catch (error) {
            console.warn('[HERO-4SKIS] Could not access Spline objects:', error);
        }

        currentRotation = rotation;
    }

    // Animate ski back to original position
    function animateBackToOriginal(skiIndex) {
        const startRot = currentRotation;
        const endRot = originalRotations[`ski${skiIndex + 1}`];
        const duration = 500; // ms
        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Easing function (ease-out-cubic)
            const eased = 1 - Math.pow(1 - progress, 3);

            const rotation = startRot + (endRot - startRot) * eased;
            applyRotation(skiIndex, rotation);

            if (progress < 1) {
                animationFrame = requestAnimationFrame(animate);
            } else {
                currentRotation = endRot;
            }
        }

        // Cancel any existing animation
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }

        animate();
    }

    // Fallback: Send message to Spline (if API available)
    function sendSplineMessage(skiIndex, rotation) {
        const skiNames = ['ALLMOUNTAIN', 'PARK', 'CARVE', 'POWDER'];

        // This would use Spline's postMessage API if available
        if (viewer.contentWindow) {
            viewer.contentWindow.postMessage({
                type: 'rotateSki',
                name: skiNames[skiIndex],
                index: skiIndex,
                rotation: rotation
            }, '*');
        }
    }

    // Initialize when DOM ready
    async function initialize() {
        await waitForSplineViewer();

        // Find container
        const container = document.querySelector('.spline-container, .hero-container, #hero-container');

        if (!container) {
            console.error('[HERO-4SKIS] No container found for hero scene');
            return;
        }

        // Create the single viewer with all 4 skis
        createHeroViewer(container);

        console.log('[HERO-4SKIS] Hero scene initialized with 4 skis in perfect quality!');
    }

    // Start
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        setTimeout(initialize, 100);
    }

    // Global debug
    window.hero4Skis = {
        status: () => {
            console.log('[HERO-4SKIS] Single scene with 4 skis');
            console.log('[HERO-4SKIS] Perfect quality - only 1 WebGL context!');
        },

        testRotation: (skiIndex, degrees) => {
            const skiNames = ['ALLMOUNTAIN', 'PARK', 'CARVE', 'POWDER'];
            console.log(`[HERO-4SKIS] Testing rotation for ${skiNames[skiIndex]} (${degrees}°)`);
            applyRotation(skiIndex, degrees);
            setTimeout(() => animateBackToOriginal(skiIndex), 1000);
        }
    };

    console.log('[HERO-4SKIS] Commands: hero4Skis.status(), hero4Skis.testRotation(0-3, degrees)');
})();
</script>

<!-- WEBFLOW SETUP -->
<!--
In Webflow, create a single container for the hero scene:

<div class="hero-container" id="hero-container"></div>

Or use existing spline-container:

<div class="spline-container"
     id="hero-container"
     data-scene="hero-animation">
</div>
-->