<style>
  /* Disable text selection for Spline scenes */
  .type-trigger, .type-trigger *,
  .ski_container, .ski_container *,
  .spinesss, .spinesss *,
  #allmountain-showcase,
  #park-showcase,
  #carve-showcase,
  #powder-showcase {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }

  /* Mobile-specific fixes */
  @media (max-width: 768px) {
    .type-trigger, .ski_container, .spinesss {
      -webkit-touch-callout: none !important;
      -webkit-user-select: none !important;
      user-select: none !important;
    }
  }
</style>

<!-- Hover text script -->
<script defer>
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const span = document.getElementById('typeSpan');
        if (!span) return;

        const defaultText = span.textContent;
        const triggers = document.querySelectorAll('.type-trigger');

        triggers.forEach(el => {
            const value = el.getAttribute('data-type');
            el.addEventListener('mouseenter', () => {
                if (value) span.textContent = value;
            });
            el.addEventListener('mouseleave', () => {
                span.textContent = defaultText;
            });
        });
    }, 100);
});
</script>

<!-- Spline Runtime with Canvas Fix -->
<script>
document.addEventListener("DOMContentLoaded", async function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const dpr = window.devicePixelRatio || 1;

    // Load runtime once globally
    if (!window.splineRuntime) {
        console.log('Loading Spline runtime...');
        window.splineRuntime = import(`${CLOUDFLARE_URL}/runtime.js`);
    }

    const activeScenes = new Map();
    const loadedScenes = new Set();
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const maxActiveScenes = isMobile ? 2 : 4;
    let currentActiveCount = 0;

    // CRITICAL: Force canvas to correct dimensions
    function forceCanvasSize(canvas) {
        const rect = canvas.getBoundingClientRect();
        const width = Math.floor(rect.width);
        const height = Math.floor(rect.height);

        const targetWidth = width * dpr;
        const targetHeight = height * dpr;

        if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
            console.log(`üîß Forcing canvas ${canvas.id} from ${canvas.width}x${canvas.height} to ${targetWidth}x${targetHeight}`);
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            return true;
        }
        return false;
    }

    // Monitor canvas for unwanted changes
    function monitorCanvas(canvas, app) {
        let checkCount = 0;
        const maxChecks = 20;

        const checkAndFix = () => {
            checkCount++;
            const fixed = forceCanvasSize(canvas);

            if (fixed) {
                console.log(`‚ö†Ô∏è Canvas ${canvas.id} was resized incorrectly, fixed it (check ${checkCount})`);

                // Also force renderer to update
                const renderer = app._scene?._renderer || app.renderer || app._renderer;
                if (renderer && renderer.setSize) {
                    const rect = canvas.getBoundingClientRect();
                    renderer.setPixelRatio(dpr);
                    renderer.setSize(Math.floor(rect.width), Math.floor(rect.height), false);
                }
            }

            if (checkCount < maxChecks) {
                setTimeout(checkAndFix, 500);
            }
        };

        // Start monitoring
        setTimeout(checkAndFix, 100);

        // Also use MutationObserver
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.attributeName === 'width' || mutation.attributeName === 'height') {
                    console.warn(`üìè Canvas ${canvas.id} was modified externally`);
                    forceCanvasSize(canvas);
                }
            }
        });

        observer.observe(canvas, {
            attributes: true,
            attributeFilter: ['width', 'height', 'style']
        });
    }

    // Scene management
    function pauseScene(canvasId) {
        const app = activeScenes.get(canvasId);
        if (app && app.pause) {
            app.pause();
            console.log(`Paused: ${canvasId}`);
        }
    }

    function resumeScene(canvasId) {
        const app = activeScenes.get(canvasId);
        if (app && app.resume) {
            app.resume();
            console.log(`Resumed: ${canvasId}`);
        }
    }

    // Load scene function
    async function loadSplineScene(canvasId, scenePath) {
        if (loadedScenes.has(canvasId)) {
            resumeScene(canvasId);
            return;
        }

        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Force canvas size BEFORE loading
        forceCanvasSize(canvas);

        try {
            console.log(`Loading: ${scenePath}`);
            const { Application } = await window.splineRuntime;

            // Create app with pixel ratio
            const app = new Application(canvas, {
                wasmPath: `${CLOUDFLARE_URL}/`,
                pixelRatio: dpr,
                antialias: true
            });

            // Load scene
            await app.load(`${CLOUDFLARE_URL}/scenes/${scenePath}/scene.splinecode`);

            // Force canvas size AFTER loading
            forceCanvasSize(canvas);

            // Start monitoring for unwanted resizes
            monitorCanvas(canvas, app);

            // Store app
            activeScenes.set(canvasId, app);
            loadedScenes.add(canvasId);
            currentActiveCount++;

            console.log(`‚úÖ Loaded: ${scenePath} (DPR: ${dpr}, Canvas: ${canvas.width}x${canvas.height})`);
        } catch (error) {
            console.error(`Failed to load ${scenePath}:`, error);
        }
    }

    // Setup intersection observer
    function setupSmartLoading(canvasId, scenePath) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                if (!loadedScenes.has(canvasId)) {
                    loadSplineScene(canvasId, scenePath);
                } else {
                    resumeScene(canvasId);
                }
            } else {
                if (activeScenes.has(canvasId)) {
                    pauseScene(canvasId);
                }
            }
        }, {
            rootMargin: '100px',
            threshold: 0.1
        });

        observer.observe(canvas);
    }

    // Initialize all scenes
    document.querySelectorAll('[data-spline-scene]').forEach(canvas => {
        const scenePath = canvas.getAttribute('data-spline-scene');
        setupSmartLoading(canvas.id, scenePath);
    });

    console.log(`Found ${document.querySelectorAll('[data-spline-scene]').length} scenes (DPR: ${dpr})`);

    // Global diagnostic function
    window.checkCanvases = function() {
        document.querySelectorAll('[data-spline-scene]').forEach(canvas => {
            const rect = canvas.getBoundingClientRect();
            const expectedWidth = Math.floor(rect.width) * dpr;
            const expectedHeight = Math.floor(rect.height) * dpr;
            const correct = (canvas.width === expectedWidth && canvas.height === expectedHeight);

            console.log(`${canvas.id}: ${correct ? '‚úÖ' : '‚ùå'} ${canvas.width}x${canvas.height} (should be ${expectedWidth}x${expectedHeight})`);
        });
    };

    // Force fix all canvases
    window.fixCanvases = function() {
        document.querySelectorAll('[data-spline-scene]').forEach(canvas => {
            forceCanvasSize(canvas);
        });
        console.log('All canvases fixed');
    };
});
</script>