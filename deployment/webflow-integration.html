<!-- 
WEBFLOW INTEGRATION SCRIPT FOR SPLINE RUNTIME PRO
Copy this entire code block and paste into:
Webflow → Project Settings → Custom Code → Footer Code
-->

<script>
document.addEventListener("DOMContentLoaded", async function () {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev'; // ✅ Your live Cloudflare URL
    
    // Global runtime cache - loads once for ENTIRE website
    if (!window.splineRuntime) {
        console.log('Loading Spline runtime (one time only)...');
        window.splineRuntime = import(`${CLOUDFLARE_URL}/runtime.js`);
    }
    
    const activeScenes = new Map(); // Track loaded scenes and their app instances
    const loadedScenes = new Set(); // Track which scenes have been loaded
    
    // Device detection for performance optimization
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const maxActiveScenes = isMobile ? 2 : 4; // Limit active scenes based on device
    let currentActiveCount = 0;
    
    // Scene management functions
    function pauseScene(canvasId) {
        const app = activeScenes.get(canvasId);
        if (app && typeof app.pause === 'function') {
            app.pause();
            console.log(`Paused scene: ${canvasId}`);
        }
    }
    
    function resumeScene(canvasId) {
        const app = activeScenes.get(canvasId);
        if (app && typeof app.resume === 'function') {
            app.resume();
            console.log(`Resumed scene: ${canvasId}`);
        }
    }
    
    function pauseLeastImportantScene() {
        // Find a scene to pause (skip hero scenes marked as priority)
        for (let [canvasId, app] of activeScenes) {
            const canvas = document.getElementById(canvasId);
            const isPriority = canvas && canvas.hasAttribute('data-priority');
            if (!isPriority) {
                pauseScene(canvasId);
                currentActiveCount--;
                return true;
            }
        }
        return false;
    }
    
    async function loadSplineScene(canvasId, scenePath) {
        if (loadedScenes.has(canvasId)) {
            // Scene already loaded, just resume it
            resumeScene(canvasId);
            return;
        }
        
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        // Check if we need to pause a scene first
        if (currentActiveCount >= maxActiveScenes) {
            if (!pauseLeastImportantScene()) {
                console.warn(`Max scenes (${maxActiveScenes}) already active, skipping load of ${canvasId}`);
                return;
            }
        }
        
        try {
            console.log(`Loading scene: ${scenePath} (${currentActiveCount + 1}/${maxActiveScenes})`);
            const { Application } = await window.splineRuntime;
            const app = new Application(canvas, {
                wasmPath: `${CLOUDFLARE_URL}/`,
                pixelRatio: window.devicePixelRatio || 1,
                antialias: true
            });

            // Force pixel ratio after creation
            setTimeout(() => {
                if (app._scene && app._scene._renderer) {
                    const dpr = window.devicePixelRatio || 1;
                    app._scene._renderer.setPixelRatio(dpr);
                    console.log(`Forced pixel ratio: ${dpr} for ${scenePath}`);
                }
            }, 100);
            
            await app.load(`${CLOUDFLARE_URL}/scenes/${scenePath}/scene.splinecode`);
            
            // Store the app instance for pause/resume control
            activeScenes.set(canvasId, app);
            loadedScenes.add(canvasId);
            currentActiveCount++;
            
            console.log(`Scene loaded: ${scenePath} (Active: ${currentActiveCount}/${maxActiveScenes})`);
        } catch (error) {
            console.error(`Failed to load ${scenePath}:`, error);
        }
    }
    
    function setupSmartLoading(canvasId, scenePath) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                // Scene entered viewport - load or resume
                if (!loadedScenes.has(canvasId)) {
                    loadSplineScene(canvasId, scenePath);
                } else {
                    resumeScene(canvasId);
                    currentActiveCount++;
                }
            } else {
                // Scene left viewport - pause to save performance
                if (activeScenes.has(canvasId)) {
                    pauseScene(canvasId);
                    currentActiveCount--;
                }
            }
        }, { 
            rootMargin: '100px', // Start loading before fully visible
            threshold: 0.1 // Trigger when 10% visible
        });
        
        observer.observe(canvas);
    }
    
    // Auto-detect and setup scenes on current page
    document.querySelectorAll('[data-spline-scene]').forEach(canvas => {
        const scenePath = canvas.getAttribute('data-spline-scene');
        setupSmartLoading(canvas.id, scenePath);
    });
    
    const sceneCount = document.querySelectorAll('[data-spline-scene]').length;
    console.log(`Found ${sceneCount} Spline scenes on this page (Device: ${isMobile ? 'Mobile' : 'Desktop'}, Max Active: ${maxActiveScenes})`);
    
    // Optional: Add global pause/resume controls
    window.splineControls = {
        pauseAll: () => {
            activeScenes.forEach((app, canvasId) => pauseScene(canvasId));
            currentActiveCount = 0;
        },
        resumeAll: () => {
            activeScenes.forEach((app, canvasId) => resumeScene(canvasId));
            currentActiveCount = activeScenes.size;
        },
        getActiveCount: () => currentActiveCount
    };
});
</script>