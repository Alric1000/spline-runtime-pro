<style>
    /* Disable text selection and link dragging for Spline scenes */
    .ski-trigger,
    .ski-trigger *,
    .colab-trigger,
    .colab-trigger *,
    spline-viewer {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        pointer-events: auto;
    }

    /* Prevent link dragging */
    .ski-trigger a,
    .ski-trigger .w-inline-block,
    .colab-trigger a,
    .colab-trigger .w-inline-block {
        -webkit-user-drag: none;
        -khtml-user-drag: none;
        -moz-user-drag: none;
        -o-user-drag: none;
        user-drag: none;
    }
</style>

<!-- Hover text script with instant touch response -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Try multiple selectors to find the text element
    let span = document.querySelector('.DYNAMIC_SKIS') ||
               document.querySelector('.dynamic-skis') ||
               document.querySelector('.dynamic_skis') ||
               document.querySelector('[class*="DYNAMIC_SKIS"]') ||
               document.querySelector('[class*="dynamic"]');

    // Debug: Log what we found
    if (!span) {
        console.error('[TEXT] Could not find DYNAMIC_SKIS element. Looking for alternatives...');
        // Try to find any element that might be the text
        const possibleElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6, .f-h3-heading, [class*="heading"]');
        console.log('[TEXT] Found possible text elements:', possibleElements.length);
        possibleElements.forEach(el => {
            console.log('[TEXT] Element:', el.className, 'Text:', el.textContent.substring(0, 20));
        });
        return;
    }

    console.log('[TEXT] Found text element:', span.className);

    const defaultText = span.textContent;
    const containers = [...document.querySelectorAll('.ski-trigger'), ...document.querySelectorAll('.colab-trigger')];
    let activeTextTouch = null;
    let isMouseDragging = false;

    containers.forEach(el => {
        const value = el.getAttribute('data-type');
        if (value) {
            // Desktop hover - only change if not dragging
            el.addEventListener('mouseenter', () => {
                if (!activeTextTouch && !isMouseDragging) {
                    span.textContent = value;
                }
            });
            el.addEventListener('mouseleave', () => {
                if (!activeTextTouch && !isMouseDragging) {
                    span.textContent = defaultText;
                }
            });

            // Mobile touch - immediate response
            el.addEventListener('touchstart', (e) => {
                activeTextTouch = el;
                span.textContent = value;
            }, { passive: true });

            el.addEventListener('touchend', () => {
                activeTextTouch = null;
                span.textContent = defaultText;
            }, { passive: true });

            el.addEventListener('touchcancel', () => {
                activeTextTouch = null;
                span.textContent = defaultText;
            }, { passive: true });
        }
    });

    // Global touch end safety
    document.addEventListener('touchend', () => {
        if (activeTextTouch) {
            activeTextTouch = null;
            span.textContent = defaultText;
        }
    }, { passive: true });

    // Expose functions for rotation script to use
    window.__textControl = {
        setMouseDragging: (state) => { isMouseDragging = state; },
        setText: (text) => { if (span) span.textContent = text; },
        getDefaultText: () => defaultText,
        setDefaultText: (text) => { 
            defaultText = text; 
            if (span && !activeTextTouch && !isMouseDragging) {
                span.textContent = text;
            }
        }
    };
});
</script>

<!-- HOME PAGE - ROTATION FOR BOTH SKIS AND COLLABS -->
<script>
// Enhanced Spline initialization with proper error handling and runtime verification
(function() {
    // Prevent double initialization
    if (window.__splineRotationInitialized) {
        console.log('[HOME] Already initialized, skipping...');
        return;
    }
    window.__splineRotationInitialized = true;

    console.log('[HOME] Initializing with click-through support...');

    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    
    // Verify runtime is available
    function verifySplineRuntime() {
        return new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max wait
            
            function checkRuntime() {
                attempts++;
                
                if (typeof customElements !== 'undefined' && customElements.get('spline-viewer')) {
                    console.log('[HOME] ✓ Spline runtime verified');
                    resolve(true);
                } else if (attempts >= maxAttempts) {
                    console.error('[HOME] ✗ Spline runtime failed to load after 5 seconds');
                    reject(new Error('Spline runtime not available'));
                } else {
                    setTimeout(checkRuntime, 100);
                }
            }
            
            checkRuntime();
        });
    }

    // Initialize Hero Ski Scene with enhanced error handling
    async function initializeHeroScene() {
        try {
            // Wait for runtime to be ready
            await verifySplineRuntime();
            
            const heroContainer = document.querySelector('.hero-scene');

            if (!heroContainer) {
                console.warn('[HOME] No .hero-scene container found - scene will not load');
                // Try alternative selectors
                const alternatives = ['.hero_scene', '[data-scene="hero"]', '.spline-hero'];
                for (const selector of alternatives) {
                    const altContainer = document.querySelector(selector);
                    if (altContainer) {
                        console.log(`[HOME] Found alternative container: ${selector}`);
                        return initializeSceneInContainer(altContainer, 'hero');
                    }
                }
                return;
            }

            if (heroContainer.querySelector('spline-viewer')) {
                console.log('[HOME] Ski scene already loaded');
                return;
            }

            return initializeSceneInContainer(heroContainer, 'hero');
            
        } catch (error) {
            console.error('[HOME] Failed to initialize hero scene:', error);
            showSceneError('hero', error.message);
        }
    }
    
    // Generic scene initialization
    function initializeSceneInContainer(container, sceneType) {
        return new Promise((resolve, reject) => {
            try {
                // Create viewer with full interactions
                const viewer = document.createElement('spline-viewer');
                // Add cache busting timestamp
                const timestamp = Date.now();
                const sceneUrl = sceneType === 'hero' 
                    ? `${CLOUDFLARE_URL}/scenes/hero-animation/scene.splinecode?v=${timestamp}`
                    : `${CLOUDFLARE_URL}/scenes/hero-colab/scene.splinecode?v=${timestamp}`;
                
                viewer.setAttribute('url', sceneUrl);
                viewer.style.width = '100%';
                viewer.style.height = '100%';
                
                // Add loading state
                container.classList.add('spline-loading');
                
                // Handle load events
                viewer.addEventListener('load', () => {
                    console.log(`[HOME] ✓ ${sceneType} scene loaded successfully`);
                    container.classList.remove('spline-loading');
                    container.classList.add('spline-loaded');
                    resolve(viewer);
                });
                
                viewer.addEventListener('error', (error) => {
                    console.error(`[HOME] ✗ ${sceneType} scene failed to load:`, error);
                    container.classList.remove('spline-loading');
                    container.classList.add('spline-error');
                    reject(error);
                });

                container.appendChild(viewer);
                console.log(`[HOME] Loading ${sceneType} scene with full interactions...`);

                // Setup rotation based on scene type
                if (sceneType === 'hero') {
                    setupHeroRotation(viewer);
                    // Add performance observer for hero scene
                    setupHeroVisibilityObserver(viewer);
                } else {
                    setupCollabRotation(viewer);
                }
                
            } catch (error) {
                reject(error);
            }
        });
    }

    // Initialize Hero Collab Scene with enhanced error handling
    async function initializeCollabScene() {
        try {
            // Wait for runtime to be ready
            await verifySplineRuntime();
            
            const collabContainer = document.querySelector('.hero-colab-scene');

            if (!collabContainer) {
                console.warn('[COLLAB] No .hero-colab-scene container found - scene will not load');
                // Try alternative selectors
                const alternatives = ['.hero_colab_scene', '[data-scene="colab"]', '.spline-colab'];
                for (const selector of alternatives) {
                    const altContainer = document.querySelector(selector);
                    if (altContainer) {
                        console.log(`[COLLAB] Found alternative container: ${selector}`);
                        return initializeSceneInContainer(altContainer, 'collab');
                    }
                }
                return;
            }

            if (collabContainer.querySelector('spline-viewer')) {
                console.log('[COLLAB] Scene already loaded');
                return;
            }

            return initializeSceneInContainer(collabContainer, 'collab');
            
        } catch (error) {
            console.error('[COLLAB] Failed to initialize collab scene:', error);
            showSceneError('collab', error.message);
        }
    }
    
    // Error display function
    function showSceneError(sceneType, message) {
        console.error(`[${sceneType.toUpperCase()}] Scene Error: ${message}`);
        
        // Create a simple error message for debugging
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            z-index: 10000;
            max-width: 300px;
        `;
        errorDiv.textContent = `Spline ${sceneType} scene failed: ${message}`;
        
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.parentNode.removeChild(errorDiv);
            }
        }, 10000);
    }

    // Setup rotation for hero ski scene
    function setupHeroRotation(viewer) {
        const triggerZones = document.querySelectorAll('.ski-trigger');

        if (triggerZones.length !== 4) {
            console.error('[HOME] Expected 4 trigger zones, found:', triggerZones.length);
            return;
        }

        let splineApp = null;
        let skiObjects = [];
        let mouseDownData = null;
        let activeTouch = null;
        let animationFrame = null;

        const DRAG_THRESHOLD = 10;
        const HORIZONTAL_RATIO = 1.5;
        const DESKTOP_ROTATION_SPEED = 0.5;
        const MOBILE_ROTATION_SPEED = 1.0;
        const DEFAULT_ROTATION = 90;
        const DEFAULT_RADIANS = DEFAULT_ROTATION * (Math.PI / 180);
        let currentRotations = [DEFAULT_ROTATION, DEFAULT_ROTATION, DEFAULT_ROTATION, DEFAULT_ROTATION];

        const SKI_MAPPING = [
            { name: 'CARVE', uuid: 'c5d6f3ff-e0a8-42e3-8fa3-3ab4f6a6a82c' },
            { name: 'PARK', uuid: '731fbf35-4ab6-40a4-b7d0-22cd41b67649' },
            { name: 'ALLMOUNTAIN', uuid: '1057c6ec-57c0-4d4a-bdd0-00999322dd99' },
            { name: 'POWDER', uuid: 'b492d3e6-5ab3-40e8-8635-8bed0b3ec600' }
        ];

        function initializeScene() {
            splineApp = viewer._spline;

            if (!splineApp) {
                setTimeout(initializeScene, 500);
                return;
            }

            console.log('[HOME] Spline app ready');

            if (splineApp.getAllObjects) {
                const allObjects = splineApp.getAllObjects();

                SKI_MAPPING.forEach((ski, index) => {
                    const obj = allObjects.find(o => o.uuid === ski.uuid);
                    if (obj) {
                        skiObjects[index] = obj;
                        console.log(`[HOME] ✓ ${ski.name} ready`);

                        if (obj.rotation) {
                            obj.rotation.y = DEFAULT_RADIANS;
                        }
                    }
                });

                if (skiObjects.filter(o => o).length === 4) {
                    console.log('[HOME] All 4 skis loaded');
                    setupInteraction();
                }
            }
        }

        function setupInteraction() {
            triggerZones.forEach((zone, index) => {
                if (!zone.hasAttribute('data-ski')) {
                    zone.setAttribute('data-ski', index);
                }

                // Prevent default drag behavior on links inside triggers
                const links = zone.querySelectorAll('a, .w-inline-block');
                links.forEach(link => {
                    link.addEventListener('dragstart', (e) => {
                        e.preventDefault();
                        return false;
                    });
                });

                zone.addEventListener('mousedown', handleMouseDown, { capture: true, passive: false });
                zone.addEventListener('touchstart', handleTouchStart, { capture: true, passive: false });
            });

            // Global listeners
            window.addEventListener('mousemove', handleMouseMove, { capture: true, passive: false });
            window.addEventListener('mouseup', handleMouseUp, { capture: true, passive: false });
            window.addEventListener('touchmove', handleTouchMove, { capture: true, passive: false });
            window.addEventListener('touchend', handleTouchEnd, { capture: true, passive: false });
            window.addEventListener('touchcancel', handleTouchEnd, { capture: true, passive: false });

            console.log('[HOME] Rotation enabled with gesture detection');
        }

        // Ski URL mapping
        const SKI_URLS = [
            'https://1000skis.webflow.io/product/carve',      // CARVE
            'https://1000skis.webflow.io/product/park',       // PARK  
            'https://1000skis.webflow.io/product/allmountain', // ALLMOUNTAIN
            'https://1000skis.webflow.io/product/powder'      // POWDER
        ];

        // MOUSE HANDLING
        function handleMouseDown(e) {
            if (!splineApp || skiObjects.length === 0) return;

            e.preventDefault();

            const zone = e.currentTarget;
            const skiIndex = parseInt(zone.dataset.ski);

            if (!isNaN(skiIndex) && skiObjects[skiIndex]) {
                const skiType = zone.getAttribute('data-type');
                if (window.__textControl && skiType) {
                    window.__textControl.setMouseDragging(true);
                    window.__textControl.setText(skiType);
                }

                mouseDownData = {
                    skiIndex: skiIndex,
                    startX: e.clientX,
                    startY: e.clientY,
                    startRotation: currentRotations[skiIndex],
                    isDragging: false,
                    isVerticalScroll: false,
                    gestureDecided: false,
                    clickTarget: e.target,
                    skiType: skiType,
                    targetUrl: SKI_URLS[skiIndex]
                };

                console.log(`[HOME] Mouse down on ski ${skiIndex} (${skiType})`);
            }
        }

        function handleMouseMove(e) {
            if (!mouseDownData) return;

            const deltaX = e.clientX - mouseDownData.startX;
            const deltaY = e.clientY - mouseDownData.startY;
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (!mouseDownData.gestureDecided && distance > DRAG_THRESHOLD) {
                mouseDownData.gestureDecided = true;
                
                // Cancel navigation since user is dragging
                if (mouseDownData.quickClickTimeout) {
                    clearTimeout(mouseDownData.quickClickTimeout);
                    mouseDownData.quickClickTimeout = null;
                }

                if (absX > absY * HORIZONTAL_RATIO) {
                    mouseDownData.isDragging = true;
                    console.log('[HOME] Horizontal drag detected - rotating');
                } else {
                    mouseDownData.isVerticalScroll = true;
                    console.log('[HOME] Vertical scroll detected - passing through');
                    if (window.__textControl) {
                        window.__textControl.setMouseDragging(false);
                        window.__textControl.setText(window.__textControl.getDefaultText());
                    }
                    mouseDownData = null;
                    return;
                }
            }

            if (mouseDownData && mouseDownData.isDragging) {
                e.preventDefault();
                e.stopPropagation();

                const rotation = mouseDownData.startRotation + (deltaX * DESKTOP_ROTATION_SPEED);
                currentRotations[mouseDownData.skiIndex] = rotation;
                applyRotation(mouseDownData.skiIndex, rotation);
            }
        }

        function handleMouseUp(e) {
            if (!mouseDownData) return;

            if (window.__textControl) {
                window.__textControl.setMouseDragging(false);
                const hoveredZone = document.elementFromPoint(e.clientX, e.clientY);
                const hoveredTrigger = hoveredZone?.closest('.ski-trigger');
                if (hoveredTrigger) {
                    const hoverType = hoveredTrigger.getAttribute('data-type');
                    window.__textControl.setText(hoverType || window.__textControl.getDefaultText());
                } else {
                    window.__textControl.setText(window.__textControl.getDefaultText());
                }
            }

            if (mouseDownData.isDragging) {
                e.preventDefault();
                e.stopPropagation();
                animateBackToDefault(mouseDownData.skiIndex);
                console.log('[HOME] Rotation ended');
            } else if (!mouseDownData.gestureDecided) {
                // Quick click detected - navigate to ski page
                if (mouseDownData.targetUrl) {
                    console.log(`[HOME] Quick click - navigating to ${mouseDownData.skiType} page`);
                    window.location.href = mouseDownData.targetUrl;
                }
            }

            mouseDownData = null;
        }

        // TOUCH HANDLING
        function handleTouchStart(e) {
            if (!splineApp || skiObjects.length === 0) return;

            const zone = e.currentTarget;
            const skiIndex = parseInt(zone.dataset.ski);

            if (!isNaN(skiIndex) && skiObjects[skiIndex]) {
                const skiType = zone.getAttribute('data-type');
                
                activeTouch = {
                    skiIndex: skiIndex,
                    startX: e.touches[0].clientX,
                    startY: e.touches[0].clientY,
                    startRotation: currentRotations[skiIndex],
                    isRotating: false,
                    blockScroll: false,
                    gestureDecided: false,
                    touchId: e.touches[0].identifier,
                    targetUrl: SKI_URLS[skiIndex]
                };

                console.log(`[HOME] Touch start on ski ${skiIndex} (${skiType})`);
            }
        }

        function handleTouchMove(e) {
            if (!activeTouch) return;

            const touch = Array.from(e.touches).find(t => t.identifier === activeTouch.touchId);
            if (!touch) return;

            const deltaX = touch.clientX - activeTouch.startX;
            const deltaY = touch.clientY - activeTouch.startY;
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (!activeTouch.gestureDecided && distance > DRAG_THRESHOLD) {
                activeTouch.gestureDecided = true;
                activeTouch.isRotating = true;
                
                // Cancel quick tap timeout since user is dragging
                if (activeTouch.quickTapTimeout) {
                    clearTimeout(activeTouch.quickTapTimeout);
                    activeTouch.quickTapTimeout = null;
                }

                if (absX > absY * HORIZONTAL_RATIO) {
                    activeTouch.blockScroll = true;
                    console.log('[HOME] Horizontal drag - rotating + blocking scroll');
                } else {
                    activeTouch.blockScroll = false;
                    console.log('[HOME] Vertical scroll - rotating + allowing scroll');
                }
            }

            if (activeTouch.isRotating) {
                if (activeTouch.blockScroll) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                const rotation = activeTouch.startRotation + (deltaX * MOBILE_ROTATION_SPEED);
                currentRotations[activeTouch.skiIndex] = rotation;
                applyRotation(activeTouch.skiIndex, rotation);
            }
        }

        function handleTouchEnd(e) {
            if (!activeTouch) return;

            const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouch.touchId);
            if (!touch) return;

            if (activeTouch.isRotating) {
                if (activeTouch.blockScroll) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                animateBackToDefault(activeTouch.skiIndex);
                console.log('[HOME] Touch ended - animating back');
            } else if (!activeTouch.gestureDecided) {
                // Quick tap detected - navigate to ski page
                if (activeTouch.targetUrl) {
                    console.log(`[HOME] Quick tap - navigating to ski page`);
                    window.location.href = activeTouch.targetUrl;
                }
            }

            activeTouch = null;
        }

        function applyRotation(skiIndex, degrees) {
            const skiObject = skiObjects[skiIndex];
            if (!skiObject || !skiObject.rotation) return;

            const radians = degrees * (Math.PI / 180);
            skiObject.rotation.y = radians;

            if (splineApp.renderer && splineApp.renderer.render) {
                splineApp.renderer.render(splineApp.scene, splineApp.camera);
            }
        }

        function animateBackToDefault(skiIndex) {
            const startRotation = currentRotations[skiIndex];
            const endRotation = DEFAULT_ROTATION;
            const duration = 500;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                const rotation = startRotation + (endRotation - startRotation) * eased;

                currentRotations[skiIndex] = rotation;
                applyRotation(skiIndex, rotation);

                if (progress < 1) {
                    animationFrame = requestAnimationFrame(animate);
                }
            }

            if (animationFrame) cancelAnimationFrame(animationFrame);
            animate();
        }

        setTimeout(initializeScene, 2000);
    }
    
    // Performance optimization for hero scene
    function setupHeroVisibilityObserver(viewer) {
        const visibilityObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.target._spline) {
                    if (entry.isIntersecting) {
                        // Resume scene rendering
                        if (entry.target._spline.renderer) {
                            entry.target._spline.renderer.setAnimationLoop(() => {
                                entry.target._spline.renderer.render(entry.target._spline.scene, entry.target._spline.camera);
                            });
                        }
                        console.log('[PERF] Hero scene resumed');
                    } else {
                        // Pause scene rendering
                        if (entry.target._spline.renderer) {
                            entry.target._spline.renderer.setAnimationLoop(null);
                        }
                        console.log('[PERF] Hero scene paused');
                    }
                }
            });
        }, { 
            threshold: 0.1,
            rootMargin: '100px' // Start loading 100px before visible
        });
        
        visibilityObserver.observe(viewer);
    }

    // Setup rotation for collab scene
    function setupCollabRotation(viewer) {
        const triggerZones = document.querySelectorAll('.colab-trigger');

        if (triggerZones.length !== 3) {
            console.error('[COLLAB] Expected 3 trigger zones, found:', triggerZones.length);
            return;
        }

        let splineApp = null;
        let collabObjects = [];
        let mouseDownData = null;
        let activeTouch = null;
        let animationFrame = null;

        const DRAG_THRESHOLD = 10;
        const HORIZONTAL_RATIO = 1.5;
        const DESKTOP_ROTATION_SPEED = 0.5;
        const MOBILE_ROTATION_SPEED = 1.0;
        const DEFAULT_ROTATION = 90;
        const DEFAULT_RADIANS = DEFAULT_ROTATION * (Math.PI / 180);
        let currentRotations = [DEFAULT_ROTATION, DEFAULT_ROTATION, DEFAULT_ROTATION];

        const COLLAB_MAPPING = [
            { name: 'SHADES', uuid: 'ecda58a5-e4e3-4409-850b-3b6ede811288' },
            { name: 'GOGGLES', uuid: '59bb33c8-b13b-462e-9b22-2ce8d50bb72c' },
            { name: 'SOFTTIE', uuid: '6cd8539d-d7bd-4aa2-a1b6-684f7a5e22d0' }
        ];

        // Collab URL mapping
        const COLLAB_URLS = [
            'https://1000skis.webflow.io/product/chimi-sunglasses',  // SHADES
            'https://1000skis.webflow.io/product/chimi-goggles',     // GOGGLES
            'https://1000skis.webflow.io/product/capeesh-belt'       // SOFTTIE (assuming this maps to belt)
        ];

        function initializeScene() {
            splineApp = viewer._spline;

            if (!splineApp) {
                setTimeout(initializeScene, 500);
                return;
            }

            console.log('[COLLAB] Spline app ready');

            if (splineApp.getAllObjects) {
                const allObjects = splineApp.getAllObjects();

                COLLAB_MAPPING.forEach((collab, index) => {
                    const obj = allObjects.find(o => o.uuid === collab.uuid);
                    if (obj) {
                        collabObjects[index] = obj;
                        console.log(`[COLLAB] ✓ ${collab.name} ready`);

                        if (obj.rotation) {
                            obj.rotation.y = DEFAULT_RADIANS;
                        }
                    }
                });

                if (collabObjects.filter(o => o).length === 3) {
                    console.log('[COLLAB] All 3 products loaded');
                    setupInteraction();
                }
            }
        }

        function setupInteraction() {
            triggerZones.forEach((zone, index) => {
                if (!zone.hasAttribute('data-collab')) {
                    zone.setAttribute('data-collab', index);
                }

                // Prevent default drag behavior on links inside triggers
                const links = zone.querySelectorAll('a, .w-inline-block');
                links.forEach(link => {
                    link.addEventListener('dragstart', (e) => {
                        e.preventDefault();
                        return false;
                    });
                });

                zone.addEventListener('mousedown', handleMouseDown, { capture: true, passive: false });
                zone.addEventListener('touchstart', handleTouchStart, { capture: true, passive: false });
            });

            // Global listeners
            window.addEventListener('mousemove', handleMouseMove, { capture: true, passive: false });
            window.addEventListener('mouseup', handleMouseUp, { capture: true, passive: false });
            window.addEventListener('touchmove', handleTouchMove, { capture: true, passive: false });
            window.addEventListener('touchend', handleTouchEnd, { capture: true, passive: false });
            window.addEventListener('touchcancel', handleTouchEnd, { capture: true, passive: false });

            console.log('[COLLAB] Rotation enabled with gesture detection');
        }

        // MOUSE HANDLING
        function handleMouseDown(e) {
            if (!splineApp || collabObjects.length === 0) return;

            e.preventDefault();

            const zone = e.currentTarget;
            const collabIndex = parseInt(zone.dataset.collab);

            if (!isNaN(collabIndex) && collabObjects[collabIndex]) {
                const collabType = zone.getAttribute('data-type');
                if (window.__textControl && collabType) {
                    window.__textControl.setMouseDragging(true);
                    window.__textControl.setText(collabType);
                }

                mouseDownData = {
                    collabIndex: collabIndex,
                    startX: e.clientX,
                    startY: e.clientY,
                    startRotation: currentRotations[collabIndex],
                    isDragging: false,
                    isVerticalScroll: false,
                    gestureDecided: false,
                    clickTarget: e.target,
                    collabType: collabType,
                    targetUrl: COLLAB_URLS[collabIndex]
                };

                console.log(`[COLLAB] Mouse down on product ${collabIndex} (${collabType})`);
            }
        }

        function handleMouseMove(e) {
            if (!mouseDownData) return;

            const deltaX = e.clientX - mouseDownData.startX;
            const deltaY = e.clientY - mouseDownData.startY;
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (!mouseDownData.gestureDecided && distance > DRAG_THRESHOLD) {
                mouseDownData.gestureDecided = true;
                
                // Cancel navigation since user is dragging
                if (mouseDownData.quickClickTimeout) {
                    clearTimeout(mouseDownData.quickClickTimeout);
                    mouseDownData.quickClickTimeout = null;
                }

                if (absX > absY * HORIZONTAL_RATIO) {
                    mouseDownData.isDragging = true;
                    console.log('[COLLAB] Horizontal drag detected - rotating');
                } else {
                    mouseDownData.isVerticalScroll = true;
                    console.log('[COLLAB] Vertical scroll detected - passing through');
                    if (window.__textControl) {
                        window.__textControl.setMouseDragging(false);
                        window.__textControl.setText(window.__textControl.getDefaultText());
                    }
                    mouseDownData = null;
                    return;
                }
            }

            if (mouseDownData && mouseDownData.isDragging) {
                e.preventDefault();
                e.stopPropagation();

                const rotation = mouseDownData.startRotation + (deltaX * DESKTOP_ROTATION_SPEED);
                currentRotations[mouseDownData.collabIndex] = rotation;
                applyRotation(mouseDownData.collabIndex, rotation);
            }
        }

        function handleMouseUp(e) {
            if (!mouseDownData) return;

            if (window.__textControl) {
                window.__textControl.setMouseDragging(false);
                const hoveredZone = document.elementFromPoint(e.clientX, e.clientY);
                const hoveredTrigger = hoveredZone?.closest('.colab-trigger');
                if (hoveredTrigger) {
                    const hoverType = hoveredTrigger.getAttribute('data-type');
                    window.__textControl.setText(hoverType || window.__textControl.getDefaultText());
                } else {
                    window.__textControl.setText(window.__textControl.getDefaultText());
                }
            }

            if (mouseDownData.isDragging) {
                e.preventDefault();
                e.stopPropagation();
                animateBackToDefault(mouseDownData.collabIndex);
                console.log('[COLLAB] Rotation ended');
            } else if (!mouseDownData.gestureDecided) {
                // Quick click detected - navigate to collab page
                if (mouseDownData.targetUrl) {
                    console.log(`[COLLAB] Quick click - navigating to ${mouseDownData.collabType} page`);
                    window.location.href = mouseDownData.targetUrl;
                }
            }

            mouseDownData = null;
        }

        // TOUCH HANDLING
        function handleTouchStart(e) {
            if (!splineApp || collabObjects.length === 0) return;

            const zone = e.currentTarget;
            const collabIndex = parseInt(zone.dataset.collab);

            if (!isNaN(collabIndex) && collabObjects[collabIndex]) {
                const collabType = zone.getAttribute('data-type');
                
                activeTouch = {
                    collabIndex: collabIndex,
                    startX: e.touches[0].clientX,
                    startY: e.touches[0].clientY,
                    startRotation: currentRotations[collabIndex],
                    isRotating: false,
                    blockScroll: false,
                    gestureDecided: false,
                    touchId: e.touches[0].identifier,
                    targetUrl: COLLAB_URLS[collabIndex]
                };

                console.log(`[COLLAB] Touch start on product ${collabIndex} (${collabType})`);
            }
        }

        function handleTouchMove(e) {
            if (!activeTouch) return;

            const touch = Array.from(e.touches).find(t => t.identifier === activeTouch.touchId);
            if (!touch) return;

            const deltaX = touch.clientX - activeTouch.startX;
            const deltaY = touch.clientY - activeTouch.startY;
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (!activeTouch.gestureDecided && distance > DRAG_THRESHOLD) {
                activeTouch.gestureDecided = true;
                activeTouch.isRotating = true;
                
                // Cancel quick tap timeout since user is dragging
                if (activeTouch.quickTapTimeout) {
                    clearTimeout(activeTouch.quickTapTimeout);
                    activeTouch.quickTapTimeout = null;
                }

                if (absX > absY * HORIZONTAL_RATIO) {
                    activeTouch.blockScroll = true;
                    console.log('[COLLAB] Horizontal drag - rotating + blocking scroll');
                } else {
                    activeTouch.blockScroll = false;
                    console.log('[COLLAB] Vertical scroll - rotating + allowing scroll');
                }
            }

            if (activeTouch.isRotating) {
                if (activeTouch.blockScroll) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                const rotation = activeTouch.startRotation + (deltaX * MOBILE_ROTATION_SPEED);
                currentRotations[activeTouch.collabIndex] = rotation;
                applyRotation(activeTouch.collabIndex, rotation);
            }
        }

        function handleTouchEnd(e) {
            if (!activeTouch) return;

            const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouch.touchId);
            if (!touch) return;

            if (activeTouch.isRotating) {
                if (activeTouch.blockScroll) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                animateBackToDefault(activeTouch.collabIndex);
                console.log('[COLLAB] Touch ended - animating back');
            } else if (!activeTouch.gestureDecided) {
                // Quick tap detected - navigate to collab page
                if (activeTouch.targetUrl) {
                    console.log(`[COLLAB] Quick tap - navigating to collab page`);
                    window.location.href = activeTouch.targetUrl;
                }
            }

            activeTouch = null;
        }

        function applyRotation(collabIndex, degrees) {
            const collabObject = collabObjects[collabIndex];
            if (!collabObject || !collabObject.rotation) return;

            const radians = degrees * (Math.PI / 180);
            collabObject.rotation.y = radians;

            if (splineApp.renderer && splineApp.renderer.render) {
                splineApp.renderer.render(splineApp.scene, splineApp.camera);
            }
        }

        function animateBackToDefault(collabIndex) {
            const startRotation = currentRotations[collabIndex];
            const endRotation = DEFAULT_ROTATION;
            const duration = 500;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                const rotation = startRotation + (endRotation - startRotation) * eased;

                currentRotations[collabIndex] = rotation;
                applyRotation(collabIndex, rotation);

                if (progress < 1) {
                    animationFrame = requestAnimationFrame(animate);
                }
            }

            if (animationFrame) cancelAnimationFrame(animationFrame);
            animate();
        }

        // Use Intersection Observer for performance optimization
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    console.log('[COLLAB] Scene became visible, initializing...');
                    setTimeout(initializeScene, 500);
                    observer.unobserve(entry.target);
                    
                    // Setup visibility observer for performance
                    setupVisibilityObserver(viewer);
                }
            });
        }, { threshold: 0.1 });
        
        observer.observe(viewer);
    }
    
    // Performance optimization: Pause scenes when not visible
    function setupVisibilityObserver(viewer) {
        const visibilityObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.target._spline) {
                    if (entry.isIntersecting) {
                        // Resume scene rendering
                        if (entry.target._spline.renderer) {
                            entry.target._spline.renderer.setAnimationLoop(() => {
                                entry.target._spline.renderer.render(entry.target._spline.scene, entry.target._spline.camera);
                            });
                        }
                        console.log('[PERF] Scene resumed');
                    } else {
                        // Pause scene rendering
                        if (entry.target._spline.renderer) {
                            entry.target._spline.renderer.setAnimationLoop(null);
                        }
                        console.log('[PERF] Scene paused');
                    }
                }
            });
        }, { 
            threshold: 0.1,
            rootMargin: '100px' // Start loading 100px before visible
        });
        
        visibilityObserver.observe(viewer);
    }

    // Aggressive scene optimization - only one scene active at a time
    let activeScene = null;
    let sceneObservers = new Map();
    
    function setupAggressiveSceneOptimization() {
        console.log('[PERF] Setting up aggressive scene optimization...');
        
        // Look for the full-screen page wrappers (100vh sections)
        const skiPageWrapper = document.querySelector('.page.wrapper_SKIS') || 
                              document.querySelector('.SKIS_CONTAINER') ||
                              document.querySelector('[class*="wrapper_SKIS"]') ||
                              document.querySelector('[class*="SKIS"]');
                              
        const collabPageWrapper = document.querySelector('.page.wrapper_COLAB') || 
                                 document.querySelector('.COLAB_CONTAINER') ||
                                 document.querySelector('[class*="wrapper_COLAB"]') ||
                                 document.querySelector('[class*="COLAB"]');
        
        if (skiPageWrapper) {
            setupSceneObserver(skiPageWrapper, 'ski');
            console.log('[PERF] ✓ Ski page wrapper observer setup on:', skiPageWrapper.className);
        } else {
            console.warn('[PERF] ✗ Ski page wrapper not found - trying scene container');
            const heroScene = document.querySelector('.hero-scene');
            if (heroScene) {
                setupSceneObserver(heroScene, 'ski');
                console.log('[PERF] ✓ Using .hero-scene as fallback');
            }
        }
        
        if (collabPageWrapper) {
            setupSceneObserver(collabPageWrapper, 'colab');
            console.log('[PERF] ✓ Collab page wrapper observer setup on:', collabPageWrapper.className);
        } else {
            console.warn('[PERF] ✗ Collab page wrapper not found - trying scene container');
            const collabScene = document.querySelector('.hero-colab-scene');
            if (collabScene) {
                setupSceneObserver(collabScene, 'colab');
                console.log('[PERF] ✓ Using .hero-colab-scene as fallback');
            }
        }
    }
    
    function setupSceneObserver(container, sceneType) {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    // Scene came into view - activate it
                    activateScene(sceneType, container);
                } else {
                    // Scene completely left view - deactivate it
                    deactivateScene(sceneType, container);
                }
            });
        }, { 
            threshold: 0.01, // Only 1% needed to stay active (almost completely off screen to deactivate)
            rootMargin: '-50px' // Extra margin - scene must be 50px off screen to deactivate
        });
        
        observer.observe(container);
        sceneObservers.set(sceneType, observer);
    }
    
    async function activateScene(sceneType, container) {
        console.log(`[PERF] Activating ${sceneType} scene...`);
        
        // Initialize the new scene first
        if (sceneType === 'ski') {
            await initializeHeroScene();
        } else if (sceneType === 'colab') {
            await initializeCollabScene();
        }
        
        console.log(`[PERF] ✓ ${sceneType} scene activated`);
        
        // Update default text based on active scene
        setTimeout(() => {
            if (window.__textControl && window.__textControl.setDefaultText) {
                if (sceneType === 'ski') {
                    window.__textControl.setDefaultText('SKIS');
                    console.log('[TEXT] ✓ Default text set to SKIS');
                } else if (sceneType === 'colab') {
                    window.__textControl.setDefaultText('COLAB');
                    console.log('[TEXT] ✓ Default text set to COLAB');
                }
            } else {
                console.warn('[TEXT] ✗ Text control not ready, retrying...');
                // Retry after text control is initialized
                setTimeout(() => {
                    if (window.__textControl && window.__textControl.setDefaultText) {
                        if (sceneType === 'ski') {
                            window.__textControl.setDefaultText('SKIS');
                            console.log('[TEXT] ✓ Default text set to SKIS (retry)');
                        } else if (sceneType === 'colab') {
                            window.__textControl.setDefaultText('COLAB');
                            console.log('[TEXT] ✓ Default text set to COLAB (retry)');
                        }
                    }
                }, 500);
            }
        }, 100);
        
        activeScene = sceneType;
    }
    
    function deactivateScene(sceneType, container) {
        return new Promise((resolve) => {
            console.log(`[PERF] Deactivating ${sceneType} scene...`);
            
            // Find and remove scene viewers
            const sceneContainer = sceneType === 'ski' 
                ? document.querySelector('.hero-scene')
                : document.querySelector('.hero-colab-scene');
                
            if (sceneContainer) {
                const viewers = sceneContainer.querySelectorAll('spline-viewer');
                viewers.forEach(viewer => {
                    // Stop any animations/rendering
                    if (viewer._spline?.renderer) {
                        viewer._spline.renderer.setAnimationLoop(null);
                        viewer._spline.renderer.dispose();
                    }
                    
                    // Remove from DOM
                    viewer.remove();
                    console.log(`[PERF] ✓ ${sceneType} viewer removed`);
                });
            }
            
            // Clear active scene if it was this one
            if (activeScene === sceneType) {
                activeScene = null;
            }
            
            console.log(`[PERF] ✓ ${sceneType} scene deactivated`);
            resolve();
        });
    }

    // Start aggressive optimization when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupAggressiveSceneOptimization);
    } else {
        setupAggressiveSceneOptimization();
    }
})();
</script>