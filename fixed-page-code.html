<style>
/* Disable text selection and touch callouts for Spline scenes */
.type-trigger,
.type-trigger *,
.ski_container,
.ski_container *,
.spinesss,
.spinesss *,
#allmountain-showcase,
#park-showcase,
#carve-showcase,
#powder-showcase {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-text-size-adjust: none;
}

/* Prevent long press context menu on mobile for Spline containers */
.type-trigger {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  pointer-events: auto;
}

/* Additional mobile-specific fixes */
@media (max-width: 768px) {
  .type-trigger,
  .ski_container,
  .spinesss {
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
  }
}
</style>

<!-- Span on hover script - deferred -->
<script defer>
document.addEventListener('DOMContentLoaded', function () {
    setTimeout(() => {
        const span = document.getElementById('typeSpan');
        if (!span) return;
        const defaultText = span.textContent;
        const triggers = document.querySelectorAll('.type-trigger');

        triggers.forEach(el => {
            const value = el.getAttribute('data-type');
            el.addEventListener('mouseenter', () => { if (value) span.textContent = value; });
            el.addEventListener('mouseleave', () => { span.textContent = defaultText; });
            el.setAttribute('tabindex', el.getAttribute('tabindex') || '0');
            el.addEventListener('focus', () => { if (value) span.textContent = value; });
            el.addEventListener('blur', () => { span.textContent = defaultText; });
            el.addEventListener('touchstart', () => { if (value) span.textContent = value; }, {passive:true});
        });

        document.addEventListener('touchstart', (e) => {
            if (![...triggers].some(t => t.contains(e.target))) {
                span.textContent = defaultText;
            }
        }, {passive:true});
    }, 100);
});
</script>

<!--Spline -->
<script>
document.addEventListener("DOMContentLoaded", async function () {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';

    // Global runtime cache - loads once for ENTIRE website
    if (!window.splineRuntime) {
        console.log('ðŸš€ Loading Spline runtime (one time only)...');
        window.splineRuntime = import(`${CLOUDFLARE_URL}/runtime.js`);
    }

    const activeScenes = new Map();
    const loadedScenes = new Set();

    // Device detection for performance optimization
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const maxActiveScenes = isMobile ? 2 : 4;
    let currentActiveCount = 0;

    // Scene management functions
    function pauseScene(canvasId) {
        const app = activeScenes.get(canvasId);
        if (app && typeof app.pause === 'function') {
            app.pause();
            console.log(`â¸ï¸ Paused scene: ${canvasId}`);
        }
    }

    function resumeScene(canvasId) {
        const app = activeScenes.get(canvasId);
        if (app && typeof app.resume === 'function') {
            app.resume();
            console.log(`â–¶ï¸ Resumed scene: ${canvasId}`);
        }
    }

    function pauseLeastImportantScene() {
        for (let [canvasId, app] of activeScenes) {
            const canvas = document.getElementById(canvasId);
            const isPriority = canvas && canvas.hasAttribute('data-priority');
            if (!isPriority) {
                pauseScene(canvasId);
                currentActiveCount--;
                return true;
            }
        }
        return false;
    }

    // SAFE pixel ratio fix
    function applyPixelRatioFix(app, canvas) {
        const dpr = window.devicePixelRatio || 1;

        // Find renderer
        let renderer = null;
        const paths = [
            () => app._scene?._renderer,
            () => app?.renderer,
            () => app?._renderer,
            () => app?.scene?.renderer
        ];

        for (const getPath of paths) {
            try {
                renderer = getPath();
                if (renderer) break;
            } catch (e) {}
        }

        if (renderer && renderer.setPixelRatio) {
            renderer.setPixelRatio(dpr);

            const rect = canvas.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            if (renderer.setSize) {
                renderer.setSize(width, height, false);
            }

            console.log(`âœ… Pixel ratio set to ${dpr} for ${canvas.id}`);
            return true;
        }

        return false;
    }

    async function loadSplineScene(canvasId, scenePath) {
        if (loadedScenes.has(canvasId)) {
            resumeScene(canvasId);
            return;
        }

        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        if (currentActiveCount >= maxActiveScenes) {
            if (!pauseLeastImportantScene()) {
                console.warn(`âš ï¸ Max scenes (${maxActiveScenes}) already active, skipping load of ${canvasId}`);
                return;
            }
        }

        try {
            console.log(`â³ Loading scene: ${scenePath} (${currentActiveCount + 1}/${maxActiveScenes})`);
            const { Application } = await window.splineRuntime;

            const app = new Application(canvas, {
                wasmPath: `${CLOUDFLARE_URL}/`,
                pixelRatio: window.devicePixelRatio || 1,
                antialias: true
            });

            await app.load(`${CLOUDFLARE_URL}/scenes/${scenePath}/scene.splinecode`);

            // Apply pixel ratio fix SAFELY
            setTimeout(() => applyPixelRatioFix(app, canvas), 100);
            setTimeout(() => applyPixelRatioFix(app, canvas), 500);
            setTimeout(() => applyPixelRatioFix(app, canvas), 1000);

            // Store the app instance
            activeScenes.set(canvasId, app);
            loadedScenes.add(canvasId);
            currentActiveCount++;

            console.log(`âœ… Scene loaded: ${scenePath} (Active: ${currentActiveCount}/${maxActiveScenes})`);
        } catch (error) {
            console.error(`âŒ Failed to load ${scenePath}:`, error);
        }
    }

    function setupSmartLoading(canvasId, scenePath) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                // Scene entered viewport - load or resume
                if (!loadedScenes.has(canvasId)) {
                    loadSplineScene(canvasId, scenePath);
                } else {
                    resumeScene(canvasId);
                    currentActiveCount++;
                }
            } else {
                // Scene left viewport - pause to save performance
                if (activeScenes.has(canvasId)) {
                    pauseScene(canvasId);
                    currentActiveCount--;
                }
            }
        }, {
            rootMargin: '100px',
            threshold: 0.1
        });

        observer.observe(canvas);
    }

    // Auto-detect and setup scenes on current page
    document.querySelectorAll('[data-spline-scene]').forEach(canvas => {
        const scenePath = canvas.getAttribute('data-spline-scene');
        setupSmartLoading(canvas.id, scenePath);
    });

    const sceneCount = document.querySelectorAll('[data-spline-scene]').length;
    console.log(`ðŸŽ¯ Found ${sceneCount} Spline scenes on this page (Device: ${isMobile ? 'Mobile' : 'Desktop'}, Max Active: ${maxActiveScenes})`);

    // Global controls
    window.splineControls = {
        pauseAll: () => {
            activeScenes.forEach((app, canvasId) => pauseScene(canvasId));
            currentActiveCount = 0;
        },
        resumeAll: () => {
            activeScenes.forEach((app, canvasId) => resumeScene(canvasId));
            currentActiveCount = activeScenes.size;
        },
        getActiveCount: () => currentActiveCount,
        checkPixelRatios: () => {
            activeScenes.forEach((app, canvasId) => {
                const canvas = document.getElementById(canvasId);
                const renderer = app._scene?._renderer;
                console.log(`${canvasId}:`, {
                    devicePixelRatio: window.devicePixelRatio,
                    rendererPixelRatio: renderer?.getPixelRatio ? renderer.getPixelRatio() : 'unknown',
                    canvasWidth: canvas.width,
                    expectedWidth: canvas.clientWidth * window.devicePixelRatio,
                    match: canvas.width === canvas.clientWidth * window.devicePixelRatio
                });
            });
        }
    };
});
</script>