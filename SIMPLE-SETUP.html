<!-- SIMPLIFIED SETUP WITH CLEAR STRUCTURE -->

<!-- ============================================
     WEBFLOW SETUP INSTRUCTIONS
     ============================================ -->

<!--
1. In Webflow Designer, create this structure for EACH ski:

   DIV (class: "spline-container", id: "allmountain-container", data-scene: "1000SKISALLMOUNTAIN")

2. That's it! Just empty divs with:
   - class: "spline-container" (same for all)
   - unique id: "allmountain-container", "park-container", "carve-container", "powder-container"
   - data-scene: the scene name

3. No embed elements needed!
-->

<!-- ============================================
     GLOBAL HEAD CODE
     ============================================ -->
<style>
/* Spline container and viewer styles */
.spline-container {
    width: 100%;
    height: 100%;
    min-height: 400px; /* Adjust as needed */
    position: relative;
}

spline-viewer {
    width: 100%;
    height: 100%;
    display: block;
}

/* Disable selection */
.spline-container,
.spline-container * {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
}
</style>

<!-- Load Spline Viewer -->
<script type="module" src="https://spline-runtime-pro.pages.dev/spline-viewer.js"></script>


<!-- ============================================
     GLOBAL FOOTER CODE
     ============================================ -->
<script>
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const dpr = window.devicePixelRatio || 1;

    console.log(`[SPLINE SETUP] Starting with pixel ratio: ${dpr}`);

    // Wait for spline-viewer to be defined
    function waitForSplineViewer() {
        return new Promise((resolve) => {
            const check = setInterval(() => {
                if (customElements.get('spline-viewer')) {
                    clearInterval(check);
                    resolve();
                }
            }, 50);
        });
    }

    // Create viewer in container
    function createViewer(container) {
        const sceneName = container.dataset.scene;
        if (!sceneName) {
            console.warn('[SPLINE SETUP] Container missing data-scene:', container);
            return;
        }

        // Check if viewer already exists
        if (container.querySelector('spline-viewer')) {
            console.log(`[SPLINE SETUP] Viewer already exists in ${container.id}`);
            return;
        }

        // Create spline-viewer element
        const viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${sceneName}/scene.splinecode`);
        viewer.setAttribute('id', container.id + '-viewer');

        // Add to container
        container.appendChild(viewer);
        console.log(`[SPLINE SETUP] Created viewer for ${sceneName}`);

        // Fix pixel ratio after creation
        fixViewerPixelRatio(viewer);
    }

    // Fix pixel ratio for a specific viewer
    function fixViewerPixelRatio(viewer) {
        // Try multiple times to ensure it sticks
        [100, 500, 1000, 2000].forEach(delay => {
            setTimeout(() => {
                // Find canvas
                const canvas = viewer.shadowRoot?.querySelector('canvas') ||
                             viewer.querySelector('canvas');

                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const width = Math.floor(rect.width);
                    const height = Math.floor(rect.height);

                    // Set correct dimensions
                    if (canvas.width !== width * dpr) {
                        canvas.width = width * dpr;
                        canvas.height = height * dpr;
                        canvas.style.width = width + 'px';
                        canvas.style.height = height + 'px';
                        console.log(`[SPLINE SETUP] Fixed canvas to ${width * dpr}x${height * dpr}`);
                    }

                    // Try to fix renderer
                    const paths = [
                        viewer._scene?._renderer,
                        viewer._application?._renderer,
                        viewer.renderer
                    ];

                    for (const renderer of paths) {
                        if (renderer?.setPixelRatio) {
                            renderer.setPixelRatio(dpr);
                            renderer.setSize?.(width, height, false);
                            console.log('[SPLINE SETUP] Renderer pixel ratio set');
                            break;
                        }
                    }
                }
            }, delay);
        });
    }

    // Main initialization
    async function initialize() {
        await waitForSplineViewer();

        // Find all spline containers
        const containers = document.querySelectorAll('.spline-container');
        console.log(`[SPLINE SETUP] Found ${containers.length} containers`);

        // Create viewer in each container
        containers.forEach(createViewer);

        // Monitor for dynamic containers
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.classList?.contains('spline-container')) {
                        console.log('[SPLINE SETUP] New container detected');
                        createViewer(node);
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }

    // Manual commands
    window.splineDebug = {
        checkAll: () => {
            document.querySelectorAll('spline-viewer').forEach(viewer => {
                const canvas = viewer.shadowRoot?.querySelector('canvas') ||
                             viewer.querySelector('canvas');
                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    const correct = canvas.width === rect.width * dpr;
                    console.log(`${viewer.id}: ${correct ? '✅' : '❌'} ${canvas.width}x${canvas.height}`);
                }
            });
        },
        fixAll: () => {
            document.querySelectorAll('spline-viewer').forEach(fixViewerPixelRatio);
        }
    };

    console.log('[SPLINE SETUP] Ready. Commands: splineDebug.checkAll(), splineDebug.fixAll()');
})();
</script>


<!-- ============================================
     WEBFLOW STRUCTURE EXAMPLE
     ============================================ -->

<!-- In Webflow, create these DIV blocks: -->

<!-- All Mountain Ski -->
<div class="spline-container" id="allmountain-container" data-scene="1000SKISALLMOUNTAIN"></div>

<!-- Park Ski -->
<div class="spline-container" id="park-container" data-scene="1000SKISPARK"></div>

<!-- Carve Ski -->
<div class="spline-container" id="carve-container" data-scene="1000SKSCARVE"></div>

<!-- Powder Ski -->
<div class="spline-container" id="powder-container" data-scene="1000SKISPOWDER"></div>


<!-- ============================================
     OPTIONAL: With hover text functionality
     ============================================ -->

<!-- If you want the hover text feature, add data-type to containers: -->
<div class="spline-container type-trigger"
     id="allmountain-container"
     data-scene="1000SKISALLMOUNTAIN"
     data-type="All Mountain">
</div>

<!-- And add this to PAGE code: -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const span = document.getElementById('typeSpan');
    if (!span) return;

    const defaultText = span.textContent;
    const triggers = document.querySelectorAll('.type-trigger');

    triggers.forEach(el => {
        const value = el.getAttribute('data-type');
        el.addEventListener('mouseenter', () => {
            if (value) span.textContent = value;
        });
        el.addEventListener('mouseleave', () => {
            span.textContent = defaultText;
        });
    });
});
</script>