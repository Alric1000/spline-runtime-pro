<!-- HERO 4-SKIS DIAGNOSTIC - Deep object inspection -->

<script async src="https://cdn.jsdelivr.net/npm/@finsweet/cookie-consent@1/fs-cc.js" fs-cc-mode="opt-in"></script>

<script>
(function() {
    const CLOUDFLARE_URL = 'https://spline-runtime-pro.pages.dev';
    const HERO_SCENE = 'hero-animation';

    console.log('[DIAGNOSTIC] Starting deep Spline inspection');

    let viewer = null;
    let splineApp = null;
    let skiObjects = [];

    const SKI_OBJECT_NAMES = [
        'normalmap test 4 bake test 300x4000 MCP',
        'normalmap test 4 bake test 300x4000 MCP 2',
        'normalmap test 4 bake test 300x4000 MCP 3',
        'normalmap test 4 bake test 300x4000 MCP 4'
    ];

    // Wait for spline-viewer
    function waitForSplineViewer() {
        return new Promise((resolve) => {
            const check = setInterval(() => {
                if (customElements.get('spline-viewer')) {
                    clearInterval(check);
                    resolve();
                }
            }, 50);
        });
    }

    // Create viewer
    function createHeroViewer(container) {
        viewer = document.createElement('spline-viewer');
        viewer.setAttribute('url', `${CLOUDFLARE_URL}/scenes/${HERO_SCENE}/scene.splinecode`);
        viewer.setAttribute('id', 'hero-viewer');
        viewer.style.width = '100%';
        viewer.style.height = '100%';
        viewer.style.display = 'block';

        container.appendChild(viewer);

        // Multiple load handlers
        viewer.addEventListener('load', onSplineLoad);
        viewer.addEventListener('ready', onSplineLoad);

        // Check periodically
        const interval = setInterval(() => {
            if (tryAccessSpline()) {
                clearInterval(interval);
                deepInspection();
            }
        }, 500);

        setTimeout(() => clearInterval(interval), 15000);

        return viewer;
    }

    // Try to access Spline
    function tryAccessSpline() {
        const attempts = [
            () => viewer._application,
            () => viewer.application,
            () => viewer._app,
            () => viewer.spline,
            () => viewer._spline,
            () => window.splineApp,
            () => viewer.getSplineApplication?.(),
            () => viewer.getApplication?.()
        ];

        for (const attempt of attempts) {
            try {
                const app = attempt();
                if (app) {
                    splineApp = app;
                    window.splineApp = app;
                    console.log('[DIAGNOSTIC] Spline accessed');
                    return true;
                }
            } catch (e) {}
        }
        return false;
    }

    // Handle load
    function onSplineLoad() {
        console.log('[DIAGNOSTIC] Load event fired');
        setTimeout(() => {
            tryAccessSpline();
            deepInspection();
        }, 1000);
    }

    // Deep inspection of objects
    function deepInspection() {
        if (!splineApp) {
            console.warn('[DIAGNOSTIC] No spline app yet');
            return;
        }

        console.log('[DIAGNOSTIC] === DEEP INSPECTION ===');

        // Get all objects
        if (!splineApp.getAllObjects) {
            console.error('[DIAGNOSTIC] No getAllObjects method');
            return;
        }

        const allObjects = splineApp.getAllObjects();

        // Find ski objects
        skiObjects = [];
        for (let i = 0; i < SKI_OBJECT_NAMES.length; i++) {
            const obj = allObjects.find(o => o.name === SKI_OBJECT_NAMES[i]);
            if (obj) {
                skiObjects[i] = obj;
                console.log(`[DIAGNOSTIC] Found ski ${i}: "${obj.name}"`);

                // Inspect object properties
                console.log(`[DIAGNOSTIC] Properties of ${obj.name}:`);
                console.log('  - Type:', obj.constructor.name);
                console.log('  - Has rotation?:', 'rotation' in obj);
                console.log('  - Has transform?:', 'transform' in obj);
                console.log('  - Has matrix?:', 'matrix' in obj);
                console.log('  - Has position?:', 'position' in obj);
                console.log('  - Has scale?:', 'scale' in obj);

                // List all properties
                const props = Object.getOwnPropertyNames(obj);
                console.log('  - All properties:', props);

                // Check for methods
                const methods = props.filter(p => typeof obj[p] === 'function');
                console.log('  - Methods:', methods);

                // Check prototype
                const proto = Object.getPrototypeOf(obj);
                if (proto) {
                    const protoMethods = Object.getOwnPropertyNames(proto)
                        .filter(p => typeof proto[p] === 'function');
                    console.log('  - Prototype methods:', protoMethods);
                }

                // Try to access transform data
                if (obj.rotation) {
                    console.log('  - rotation value:', obj.rotation);
                }
                if (obj.transform) {
                    console.log('  - transform value:', obj.transform);
                }
                if (obj.matrix) {
                    console.log('  - matrix value:', obj.matrix);
                }
            }
        }
    }

    // Test different rotation methods
    function testRotationMethods(objIndex, degrees) {
        const obj = skiObjects[objIndex];
        if (!obj) {
            console.error('[DIAGNOSTIC] No object at index', objIndex);
            return;
        }

        const radians = degrees * (Math.PI / 180);

        console.log(`[DIAGNOSTIC] Testing rotation methods for object ${objIndex}:`);

        // Method 1: Direct rotation property
        try {
            if (obj.rotation) {
                const originalY = obj.rotation.y;
                obj.rotation.y = radians;
                console.log('  ✓ Set rotation.y directly');

                // Check if it changed
                setTimeout(() => {
                    if (obj.rotation.y === radians) {
                        console.log('    -> Value persisted:', obj.rotation.y);
                    } else {
                        console.log('    -> Value reverted:', obj.rotation.y);
                    }
                }, 100);
            }
        } catch (e) {
            console.log('  ✗ rotation.y failed:', e.message);
        }

        // Method 2: setRotation method
        try {
            if (obj.setRotation) {
                obj.setRotation(0, radians, 0);
                console.log('  ✓ Called setRotation()');
            }
        } catch (e) {
            console.log('  ✗ setRotation failed:', e.message);
        }

        // Method 3: setRotationY
        try {
            if (obj.setRotationY) {
                obj.setRotationY(radians);
                console.log('  ✓ Called setRotationY()');
            }
        } catch (e) {
            console.log('  ✗ setRotationY failed:', e.message);
        }

        // Method 4: Transform matrix
        try {
            if (obj.transform) {
                obj.transform.rotation.y = radians;
                console.log('  ✓ Set transform.rotation.y');
            }
        } catch (e) {
            console.log('  ✗ transform.rotation.y failed:', e.message);
        }

        // Method 5: Update matrix
        try {
            if (obj.updateMatrix) {
                obj.rotation.y = radians;
                obj.updateMatrix();
                console.log('  ✓ Called updateMatrix()');
            }
        } catch (e) {
            console.log('  ✗ updateMatrix failed:', e.message);
        }

        // Method 6: Set property
        try {
            if (obj.setProperty) {
                obj.setProperty('rotation.y', radians);
                console.log('  ✓ Called setProperty()');
            }
        } catch (e) {
            console.log('  ✗ setProperty failed:', e.message);
        }

        // Force render
        try {
            if (splineApp.render) {
                splineApp.render();
                console.log('  ✓ Called app.render()');
            }
        } catch (e) {}

        // Check for needsUpdate flags
        try {
            if (obj.needsUpdate !== undefined) {
                obj.needsUpdate = true;
                console.log('  ✓ Set needsUpdate flag');
            }
        } catch (e) {}
    }

    // Test Spline Events API
    function testEventsAPI() {
        console.log('[DIAGNOSTIC] Testing Spline Events API:');

        // Check viewer methods
        if (viewer.emitEvent) {
            console.log('  ✓ viewer.emitEvent exists');
            try {
                viewer.emitEvent('rotate', { target: SKI_OBJECT_NAMES[0], value: 45 });
                console.log('    -> Sent rotate event');
            } catch (e) {
                console.log('    -> Error:', e.message);
            }
        }

        if (viewer.emit) {
            console.log('  ✓ viewer.emit exists');
        }

        if (viewer.trigger) {
            console.log('  ✓ viewer.trigger exists');
        }

        // Check app methods
        if (splineApp) {
            if (splineApp.emitEvent) {
                console.log('  ✓ app.emitEvent exists');
            }
            if (splineApp.setVariable) {
                console.log('  ✓ app.setVariable exists');
                try {
                    splineApp.setVariable('rotation1', 45);
                    console.log('    -> Set variable');
                } catch (e) {
                    console.log('    -> Error:', e.message);
                }
            }
        }
    }

    // Initialize
    async function initialize() {
        await waitForSplineViewer();

        const container = document.querySelector('.spline-container, .hero-container, #hero-container');
        if (!container) {
            console.error('[DIAGNOSTIC] No container found');
            return;
        }

        createHeroViewer(container);
        console.log('[DIAGNOSTIC] Viewer created');
    }

    // Start
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        setTimeout(initialize, 100);
    }

    // Global diagnostic tools
    window.diag = {
        // Inspect Spline app
        inspect: () => {
            tryAccessSpline();
            deepInspection();
        },

        // Test rotation on ski
        testRotation: (skiIndex, degrees) => {
            if (!skiObjects[skiIndex]) {
                console.error('[DIAGNOSTIC] Ski not found. Run diag.inspect() first');
                return;
            }
            testRotationMethods(skiIndex, degrees);
        },

        // Test events API
        testEvents: () => {
            testEventsAPI();
        },

        // Get object details
        getObject: (index) => {
            const obj = skiObjects[index];
            if (!obj) {
                console.error('[DIAGNOSTIC] No object at index', index);
                return;
            }
            console.log('[DIAGNOSTIC] Object details:');
            console.dir(obj);
            return obj;
        },

        // List all scene objects with details
        listAll: () => {
            if (!splineApp?.getAllObjects) {
                console.error('[DIAGNOSTIC] Spline not ready');
                return;
            }
            const objects = splineApp.getAllObjects();
            console.log('[DIAGNOSTIC] All objects in scene:');
            objects.forEach((obj, i) => {
                console.log(`${i}: ${obj.name}`);
                if (obj.type) console.log(`   Type: ${obj.type}`);
                if (obj.rotation) console.log(`   Rotation:`, obj.rotation);
                if (obj.position) console.log(`   Position:`, obj.position);
            });
        },

        // Try to rotate using various methods
        rotate: (skiIndex, degrees) => {
            const obj = skiObjects[skiIndex];
            if (!obj) {
                console.error('[DIAGNOSTIC] No ski at index', skiIndex);
                return;
            }

            const radians = degrees * (Math.PI / 180);

            // Try everything
            console.log(`[DIAGNOSTIC] Attempting all rotation methods for ski ${skiIndex}:`);

            // Direct assignment
            if (obj.rotation && obj.rotation.y !== undefined) {
                obj.rotation.y = radians;
                console.log('  - Set rotation.y =', radians);
            }

            // Three.js style
            if (obj.rotateY) {
                obj.rotateY(radians);
                console.log('  - Called rotateY()');
            }

            // Spline style
            if (obj.setRotation) {
                obj.setRotation(0, radians, 0);
                console.log('  - Called setRotation()');
            }

            // Matrix update
            if (obj.updateMatrix) {
                obj.updateMatrix();
                console.log('  - Called updateMatrix()');
            }

            // Force updates
            if (obj.needsUpdate !== undefined) {
                obj.needsUpdate = true;
            }
            if (obj.matrixNeedsUpdate !== undefined) {
                obj.matrixNeedsUpdate = true;
            }

            // Render
            if (splineApp.render) {
                splineApp.render();
                console.log('  - Called render()');
            }
            if (splineApp.needsRender) {
                splineApp.needsRender = true;
            }
        }
    };

    console.log('[DIAGNOSTIC] Commands:');
    console.log('  diag.inspect()           - Deep inspection of objects');
    console.log('  diag.testRotation(0, 45) - Test rotation methods on ski 0');
    console.log('  diag.testEvents()        - Test Spline Events API');
    console.log('  diag.getObject(0)        - Get detailed object info');
    console.log('  diag.listAll()           - List all scene objects');
    console.log('  diag.rotate(0, 45)       - Try all rotation methods');
})();
</script>

<!-- WEBFLOW -->
<!--
<div class="hero-container" id="hero-container"></div>
-->